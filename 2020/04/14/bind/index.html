<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><div class="ball"></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span id="busuanzi_container_site_uv">本站总访问量<span id="busuanzi_value_site_uv"></span>次</span></div><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.2",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="前言数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有MVC,MVP,MVVM。比较常见的实现方式有  脏值检查 （Angular1.X) 数据劫持 发布订阅模式  然而vue 是采用数据劫持和发布订阅模式相结合的方式实现的。vue3之前都是通过Object.defineProperty数据劫持实现的，vue3"><meta name="keywords" content="JS"><meta property="og:type" content="article"><meta property="og:title" content="数据双向绑定简单实现"><meta property="og:url" content="http://yoursite.com/2020/04/14/bind/index.html"><meta property="og:site_name" content="sherryJiang . Blog"><meta property="og:description" content="前言数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有MVC,MVP,MVVM。比较常见的实现方式有  脏值检查 （Angular1.X) 数据劫持 发布订阅模式  然而vue 是采用数据劫持和发布订阅模式相结合的方式实现的。vue3之前都是通过Object.defineProperty数据劫持实现的，vue3"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-04-14T03:12:28.413Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据双向绑定简单实现"><meta name="twitter:description" content="前言数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有MVC,MVP,MVVM。比较常见的实现方式有  脏值检查 （Angular1.X) 数据劫持 发布订阅模式  然而vue 是采用数据劫持和发布订阅模式相结合的方式实现的。vue3之前都是通过Object.defineProperty数据劫持实现的，vue3"><link rel="alternate" href="/atom.xml" title="sherryJiang . Blog" type="application/atom+xml"><link rel="canonical" href="http://yoursite.com/2020/04/14/bind/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>数据双向绑定简单实现 | sherryJiang . Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/SherryJiang1130"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">sherryJiang . Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">F E . 干物妹</h1></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/bind/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="SherryJiang"><meta itemprop="description" content><meta itemprop="image" content="/images/xiaomai.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="sherryJiang . Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据双向绑定简单实现</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-04-14 11:12:28" itemprop="dateCreated datePublished" datetime="2020-04-14T11:12:28+08:00">2020-04-14</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有MVC,MVP,MVVM。比较常见的实现方式有</p><ul><li>脏值检查 （Angular1.X)</li><li>数据劫持</li><li>发布订阅模式</li></ul><p>然而vue 是采用数据劫持和发布订阅模式相结合的方式实现的。<br>vue3之前都是通过Object.defineProperty数据劫持实现的，vue3改用Proxy实现了，今天就简单用两种方式实现一下</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>关于Object.defineProperty的用法 &gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">戳这里</a></p><p>get和set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let modeng = &#123;&#125;</span><br><span class="line">let name</span><br><span class="line">Object.defineProperty(modeng, &apos;name&apos;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        console.log(&apos;获取name&apos;)</span><br><span class="line">        return name</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        console.log(&apos;设置name&apos;)</span><br><span class="line">        name = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">modeng.name = 1; // 执行set</span><br><span class="line">console.log(modeng.name) // 执行get</span><br></pre></td></tr></table></figure><p>MVVM模式在于数据和视图的同步更新，所以我们就需要监听数据变化通知视图，监听视图变化更新数据，监听视图变化这个比较简单，就是添加监听事件就可以了，那个监听数据变化就需要用到Object.definProperty去实现。<br>那么我们需要一个监听器Observer来监听变化，得知属性变化之后我们需要一个Watcher订阅者来更新视图，另外还需要一个Compile指令解析器，用于解析节点元素的指令与初始化视图.</p><ul><li>Observer 监听器：监听属性的变化通知订阅者</li><li>Watcher 订阅者：收到属性变化，更新视图</li><li>Compile 解析器：解析指令，初始化模板，绑定订阅者</li></ul><h3 id="Observer监听器"><a href="#Observer监听器" class="headerlink" title="Observer监听器"></a>Observer监听器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">          observer(value)</span><br><span class="line">          let dep = new Dep()</span><br><span class="line">          Object.defineProperty(data, key, &#123;</span><br><span class="line">              get() &#123;</span><br><span class="line">                  if (Dep.target) &#123;</span><br><span class="line">                      dep.addSubs(Dep.target)</span><br><span class="line">                  &#125;</span><br><span class="line">                  return value</span><br><span class="line"></span><br><span class="line">              &#125;,</span><br><span class="line">              set(newValue) &#123;</span><br><span class="line">                  if (value != newValue) &#123;</span><br><span class="line">                      value = newValue</span><br><span class="line">                      dep.notify() //通知订阅</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function observer(data) &#123;</span><br><span class="line">          if (!data || typeof data != &apos;object&apos;) &#123;</span><br><span class="line">              return</span><br><span class="line">          &#125;</span><br><span class="line">          Object.keys(data).forEach(key =&gt; &#123;</span><br><span class="line">              defineReactive(data, key, data[key])</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function Dep() &#123;</span><br><span class="line">          this.subs = []</span><br><span class="line">      &#125;</span><br><span class="line">      Dep.prototype.addSubs = function (sub) &#123;</span><br><span class="line">          this.subs.push(sub)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Dep.prototype.notify = function () &#123;</span><br><span class="line">          console.log(&apos;属性变化，通知Watcher更新视图&apos;)</span><br><span class="line">          this.subs.forEach(ele =&gt; ele.update())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Dep.target = null</span><br></pre></td></tr></table></figure><p> 下面我们来测试一个这个监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let demo = &#123;</span><br><span class="line">          name: &apos;test&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      observer(demo)</span><br><span class="line">      demo.name=&apos;aaa&apos;</span><br><span class="line">      console.log(demo.name)</span><br></pre></td></tr></table></figure><p>看到控制台打印出了’属性变化，通知Watcher更新视图’,说明监听器添加成功</p><h3 id="Watcher订阅者"><a href="#Watcher订阅者" class="headerlink" title="Watcher订阅者"></a>Watcher订阅者</h3><p> 下面我们来实现Watcher,Watcher主要是接收属性变化的通知，然后触发函数去更新视图，分两步：</p><ol><li><p>把Watcher添加大Dep容器中</p></li><li><p>接收到属性变化通知，触发视图更新函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> function Watcher(obj, key, callback) &#123;</span><br><span class="line">    Dep.target = this </span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.callback = callback</span><br><span class="line">    this.value = obj[key] // 通过get 添加到Dep</span><br><span class="line">    Dep.target = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = function () &#123;</span><br><span class="line">    // 获取新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    //调用update更新Dom</span><br><span class="line">    this.callback(this.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是Watcher的简单实现，首先将Dep.target指向this,从而使得收集到了对应的Watcher,在派发更新的时候取出对应的Watcher,<br>然后执行update函数。</p><p>以上我们基本实现了一个简单的双向绑定, <a href="https://jsbin.com/xefowokora/edit?html,css,js,output" target="_blank" rel="noopener">查看效果</a></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy对象是ES6新加进来的，原意是代理，js中用作代理器。<br>它主要用于改变某些操作的默认行为，等同于在语言层面做修改，所以属于一种”元编程（meta programming）”，即对编程语言进行编程，<br>它在目标对象的外层搭建了一层拦截，外界对目标对象的 某些操作，会通过这层拦截。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">具体用法戳这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handle = &#123;</span><br><span class="line">        get(obj, key,receiver) &#123;</span><br><span class="line">            return Reflect.get(obj,key,receiver)||222</span><br><span class="line">        &#125;,</span><br><span class="line">        set(obj, key, value,receiver) &#123;</span><br><span class="line">            Reflect.set(obj,key,value,receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tempObj=&#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">    let p = new Proxy(tempObj, handle)</span><br><span class="line"></span><br><span class="line">    console.log(p.a) // 1</span><br><span class="line">    console.log(p.b) // 222</span><br><span class="line">    p.c=111</span><br><span class="line">    console.log(tempObj.c) // 111</span><br></pre></td></tr></table></figure></li></ol><p>由以上代码中打印的tempObj.c=111，可知，实际在new Proxy的过程中，实例对象是对第一个参数对象的浅拷贝，但是这里对tempObj进行操作并不会触发get,set。</p><p>接下来用Proxy实现数据双向绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function proxyObserver(obj, setBind, getLogger) &#123;</span><br><span class="line">           if (!obj || typeof obj != &apos;object&apos;) &#123;</span><br><span class="line">               return</span><br><span class="line">           &#125;</span><br><span class="line">           const handle = &#123;</span><br><span class="line">               get(target, key, receiver) &#123;</span><br><span class="line">                   //receiver 为上下文this对象</span><br><span class="line">                  //getLogger()</span><br><span class="line">                   return Reflect.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">               &#125;,</span><br><span class="line">               set(target, key, value, receiver) &#123;</span><br><span class="line">                   // receiver 一般为proxy实例</span><br><span class="line">                   setBind(value, key)</span><br><span class="line">                   Reflect.set(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           Object.keys(obj).forEach(ele =&gt; &#123;</span><br><span class="line">               if (!!ele &amp;&amp; typeof ele === &apos;object&apos;) &#123;</span><br><span class="line">                   obj[ele] = proxyObserver(obj[ele], setBind, getLogger)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">           return new Proxy(obj, handle)</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/yuximidece/edit?html,css,js,output" target="_blank" rel="noopener">戳这里查看效果</a></p></blockquote><h2 id="对比优劣势"><a href="#对比优劣势" class="headerlink" title="对比优劣势"></a>对比优劣势</h2><p>从代码量上就能明显看出Proxy代码要少很多，实现简洁许多，两者相比优劣势如下:<br>Object.defineProperty：</p><ol><li>拦截的是对象的属性</li><li>无法监听数组变化</li><li>通过遍历对象属性修改，</li><li>兼容性较好IE9及以上</li></ol><p>Proxy:</p><ol><li>监听的是对象，而非某个属性</li><li>可以直接监听数组变化，</li><li>返回一个新对象（浅拷贝）</li><li>拦截方式多样，多达13种，除了get,set 还有apply、ownKeys、deleteProperty、has等。</li><li>兼容性较差 IE不支持</li></ol><h2 id="Compile-解析器"><a href="#Compile-解析器" class="headerlink" title="Compile 解析器"></a>Compile 解析器</h2><p>Compile的作用有两个，一个是解析指令初始化模板，另一个是添加订阅，绑定更新函数,这里只以v-modal为例<br>在解析的过程中会频繁操作DOM，所以用createDocumentFragment来保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">function Compile(context) &#123;</span><br><span class="line">            this.context = context;</span><br><span class="line">            this.el = context.$el;</span><br><span class="line">            this.fragment = null;</span><br><span class="line">            this.init();</span><br><span class="line">        &#125;</span><br><span class="line">        Compile.prototype = &#123;</span><br><span class="line">            init: function () &#123;</span><br><span class="line">                this.fragment = this.nodeFragment(this.el);</span><br><span class="line">            &#125;,</span><br><span class="line">            nodeFragment: function (el) &#123;</span><br><span class="line">                const fragment = document.createDocumentFragment();</span><br><span class="line">                let child = el.firstChild;</span><br><span class="line">                //将子节点，全部移动文档片段里</span><br><span class="line">                while (child) &#123;</span><br><span class="line">                    fragment.appendChild(child);</span><br><span class="line">                    child = el.firstChild;</span><br><span class="line">                &#125;</span><br><span class="line">                return fragment;</span><br><span class="line">            &#125;,</span><br><span class="line">            compileNode: function (fragment) &#123;</span><br><span class="line">                let childNodes = fragment.childNodes;</span><br><span class="line">                [...childNodes].forEach(node =&gt; &#123;</span><br><span class="line">                    let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">                    let text = node.textContent;</span><br><span class="line">                    if (this.isElementNode(node)) &#123;</span><br><span class="line">                        this.compile(node); //渲染指令模板</span><br><span class="line">                    &#125; else if (this.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">                        let prop = RegExp.$1;</span><br><span class="line">                        this.compileText(node, prop); //渲染&#123;&#123;&#125;&#125; 模板</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //递归编译子节点</span><br><span class="line">                    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                        this.compileNode(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            compile: function (node) &#123;</span><br><span class="line">                let nodeAttrs = node.attributes;</span><br><span class="line">                [...nodeAttrs].forEach(attr =&gt; &#123;</span><br><span class="line">                    let name = attr.name;</span><br><span class="line">                    if (this.isDirective(name)) &#123;</span><br><span class="line">                        let value = attr.value;</span><br><span class="line">                        if (name === &quot;v-model&quot;) &#123;</span><br><span class="line">                            this.compileModel(node, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        node.removeAttribute(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            //对所有子节点进行判断，1.初始化视图数据,2.绑定更新函数的订阅器</span><br><span class="line">            compileElement: function (el) &#123;</span><br><span class="line">                var childNodes = el.childNodes;</span><br><span class="line">                var self = this;</span><br><span class="line">                [].slice.call(childNodes).forEach(function (node) &#123;</span><br><span class="line">                    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; //匹配&quot; &#123;&#123;&#125;&#125; &quot;</span><br><span class="line">                    var text = node.textContent;</span><br><span class="line"></span><br><span class="line">                    if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; //判断&quot; &#123;&#123;&#125;&#125; &quot;</span><br><span class="line">                        self.compileText(node, reg.exec(text)[1]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                        self.compileElement(node); //// 继续递归遍历子节点</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            //初始化视图updateText和生成订阅器:</span><br><span class="line">            compileText: function (node, exp) &#123;</span><br><span class="line">                var self = this;</span><br><span class="line">                var initText = this.context[exp]; //代理访问self_vue.data.name1 -&gt; self_vue.name1</span><br><span class="line">                this.updateText(node, initText); //将初始化的数据初始化到视图中</span><br><span class="line">                new Watcher(this.context, exp, function (value) &#123; //&#123;&#125;，name, // 生成订阅器并绑定更新函数</span><br><span class="line">                    self.updateText(node, value);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            updateText: function (node, value) &#123;</span><br><span class="line">                node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class="line">            &#125;,</span><br><span class="line">            isTextNode: function (node) &#123;</span><br><span class="line">                return node.nodeType == 3; //文本节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JS/" rel="tag"><i class="fa fa-tag"></i> # JS</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/04/08/algorithm/" rel="next" title="我的树洞"><i class="fa fa-chevron-left"></i> 我的树洞</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2020/04/16/virtualDom/" rel="prev" title="Virtual Dom">Virtual Dom<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/xiaomai.gif" alt="SherryJiang"><p class="site-author-name" itemprop="name">SherryJiang</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SherryJiang1130" title="GitHub &rarr; https://github.com/SherryJiang1130" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:13501579071@163.com" title="E-Mail &rarr; mailto:13501579071@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i> E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://example.com" title="http://example.com" rel="noopener" target="_blank">Title</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-defineProperty"><span class="nav-number">2.</span> <span class="nav-text">Object.defineProperty</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer监听器"><span class="nav-number">2.1.</span> <span class="nav-text">Observer监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watcher订阅者"><span class="nav-number">2.2.</span> <span class="nav-text">Watcher订阅者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy"><span class="nav-number">3.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比优劣势"><span class="nav-number">4.</span> <span class="nav-text">对比优劣势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compile-解析器"><span class="nav-number">5.</span> <span class="nav-text">Compile 解析器</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">SherryJiang</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script></body></html>