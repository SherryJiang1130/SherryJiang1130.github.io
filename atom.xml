<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sherryJiang . Blog</title>
  
  <subtitle>F E . 干物妹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-16T03:09:43.207Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SherryJiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Virtual Dom</title>
    <link href="http://yoursite.com/2020/04/16/virtualDom/"/>
    <id>http://yoursite.com/2020/04/16/virtualDom/</id>
    <published>2020-04-16T03:09:43.000Z</published>
    <updated>2020-04-16T03:09:43.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>Virtual Dom本质上就是js 对象，这个对象是对real Dom的描述。</p><p>优缺点：</p><ul><li><p>局部更新，批处理可以保证比较高效的渲染和比较少的性能损耗</p></li><li><p>跨平台，由于是js对象，既可以用于浏览器，也可以用于SSR</p></li><li><p>首次渲染大量DOM时，由于多了一层虚拟DOM计算，会比真实DOM渲染慢</p></li></ul><p>综上，对于dom操作比较少，仅仅是展示类的页面使用真实DOM更高效，如果有大量的DOM操作使用虚拟DOM更能提高性能。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><ol><li>js对象描述dom</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">    this.tagName = tagName</span><br><span class="line">    this.props = props</span><br><span class="line">    this.children = children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">  var el = document.createElement(this.tagName) // 根据tagName构建</span><br><span class="line">  var props = this.props</span><br><span class="line"></span><br><span class="line">  for (var propName in props) &#123; // 设置节点的DOM属性</span><br><span class="line">    var propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var children = this.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(function (child) &#123;</span><br><span class="line">    var childEl = (child instanceof Element)</span><br><span class="line">      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</span><br><span class="line">      : document.createTextNode(child) // 如果字符串，只构建文本节点</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let el =function (tagName, props, children) &#123;</span><br><span class="line">    return new Element(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let ul = el(&apos;ul&apos;, &#123;</span><br><span class="line">    id: &apos;list&apos;</span><br><span class="line">&#125;, [</span><br><span class="line">    el(&apos;li&apos;, &#123;</span><br><span class="line">        class: &apos;item&apos;</span><br><span class="line">    &#125;, [&apos;Item 1&apos;]),</span><br><span class="line">    el(&apos;li&apos;, &#123;</span><br><span class="line">        class: &apos;item&apos;</span><br><span class="line">    &#125;, [&apos;Item 2&apos;]),</span><br><span class="line">    el(&apos;li&apos;, &#123;</span><br><span class="line">        class: &apos;item&apos;</span><br><span class="line">    &#125;, [&apos;Item 3&apos;])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">let ulRoot = ul.render()</span><br><span class="line">document.body.appendChild(ulRoot)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/mijejexuro/edit?html,css,js,output" target="_blank" rel="noopener">查看效果</a></p></blockquote><ol start="2"><li>Virtual Dom 算法</li></ol><p>Virtual Dom的优点之一是局部更新，就是因为diff算法。两颗树的完全的 diff 算法时间复杂度为 O(n^3) 。但是在前端当中，你很少会跨越层级的移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比算法复杂度是O(n)。</p><ul><li>深度优先遍历，记录差异<br>在对比的过程中，会对两颗树进行深度优先的遍历，这样每个节点都有一个唯一的标识，在深度遍历的过程中，每遍历到一个节点就对比该节点是否有变化，如果有变化就记录到一个对象中。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是虚拟DOM&quot;&gt;&lt;a href=&quot;#什么是虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟DOM&quot;&gt;&lt;/a&gt;什么是虚拟DOM&lt;/h2&gt;&lt;p&gt;Virtual Dom本质上就是js 对象，这个对象是对real Dom的描述。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>数据双向绑定简单实现</title>
    <link href="http://yoursite.com/2020/04/14/bind/"/>
    <id>http://yoursite.com/2020/04/14/bind/</id>
    <published>2020-04-14T03:12:28.000Z</published>
    <updated>2020-04-14T03:12:28.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有MVC,MVP,MVVM。比较常见的实现方式有</p><ul><li>脏值检查 （Angular1.X)</li><li>数据劫持</li><li>发布订阅模式</li></ul><p>然而vue 是采用数据劫持和发布订阅模式相结合的方式实现的。<br>vue3之前都是通过Object.defineProperty数据劫持实现的，vue3改用Proxy实现了，今天就简单用两种方式实现一下</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>关于Object.defineProperty的用法 &gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">戳这里</a></p><p>get和set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let modeng = &#123;&#125;</span><br><span class="line">let name</span><br><span class="line">Object.defineProperty(modeng, &apos;name&apos;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        console.log(&apos;获取name&apos;)</span><br><span class="line">        return name</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        console.log(&apos;设置name&apos;)</span><br><span class="line">        name = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">modeng.name = 1; // 执行set</span><br><span class="line">console.log(modeng.name) // 执行get</span><br></pre></td></tr></table></figure><p>MVVM模式在于数据和视图的同步更新，所以我们就需要监听数据变化通知视图，监听视图变化更新数据，监听视图变化这个比较简单，就是添加监听事件就可以了，那个监听数据变化就需要用到Object.definProperty去实现。<br>那么我们需要一个监听器Observer来监听变化，得知属性变化之后我们需要一个Watcher订阅者来更新视图，另外还需要一个Compile指令解析器，用于解析节点元素的指令与初始化视图.</p><ul><li>Observer 监听器：监听属性的变化通知订阅者</li><li>Watcher 订阅者：收到属性变化，更新视图</li><li>Compile 解析器：解析指令，初始化模板，绑定订阅者</li></ul><h3 id="Observer监听器"><a href="#Observer监听器" class="headerlink" title="Observer监听器"></a>Observer监听器</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">          observer(value)</span><br><span class="line">          let dep = new Dep()</span><br><span class="line">          Object.defineProperty(data, key, &#123;</span><br><span class="line">              get() &#123;</span><br><span class="line">                  if (Dep.target) &#123;</span><br><span class="line">                      dep.addSubs(Dep.target)</span><br><span class="line">                  &#125;</span><br><span class="line">                  return value</span><br><span class="line"></span><br><span class="line">              &#125;,</span><br><span class="line">              set(newValue) &#123;</span><br><span class="line">                  if (value != newValue) &#123;</span><br><span class="line">                      value = newValue</span><br><span class="line">                      dep.notify() //通知订阅</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function observer(data) &#123;</span><br><span class="line">          if (!data || typeof data != &apos;object&apos;) &#123;</span><br><span class="line">              return</span><br><span class="line">          &#125;</span><br><span class="line">          Object.keys(data).forEach(key =&gt; &#123;</span><br><span class="line">              defineReactive(data, key, data[key])</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function Dep() &#123;</span><br><span class="line">          this.subs = []</span><br><span class="line">      &#125;</span><br><span class="line">      Dep.prototype.addSubs = function (sub) &#123;</span><br><span class="line">          this.subs.push(sub)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Dep.prototype.notify = function () &#123;</span><br><span class="line">          console.log(&apos;属性变化，通知Watcher更新视图&apos;)</span><br><span class="line">          this.subs.forEach(ele =&gt; ele.update())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Dep.target = null</span><br></pre></td></tr></table></figure><p> 下面我们来测试一个这个监听器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let demo = &#123;</span><br><span class="line">          name: &apos;test&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      observer(demo)</span><br><span class="line">      demo.name=&apos;aaa&apos;</span><br><span class="line">      console.log(demo.name)</span><br></pre></td></tr></table></figure><p>看到控制台打印出了’属性变化，通知Watcher更新视图’,说明监听器添加成功</p><h3 id="Watcher订阅者"><a href="#Watcher订阅者" class="headerlink" title="Watcher订阅者"></a>Watcher订阅者</h3><p>  下面我们来实现Watcher,Watcher主要是接收属性变化的通知，然后触发函数去更新视图，分两步：</p><ol><li><p>把Watcher添加大Dep容器中</p></li><li><p>接收到属性变化通知，触发视图更新函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> function Watcher(obj, key, callback) &#123;</span><br><span class="line">    Dep.target = this </span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.callback = callback</span><br><span class="line">    this.value = obj[key] // 通过get 添加到Dep</span><br><span class="line">    Dep.target = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = function () &#123;</span><br><span class="line">    // 获取新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    //调用update更新Dom</span><br><span class="line">    this.callback(this.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是Watcher的简单实现，首先将Dep.target指向this,从而使得收集到了对应的Watcher,在派发更新的时候取出对应的Watcher,<br>然后执行update函数。</p><p>以上我们基本实现了一个简单的双向绑定, <a href="https://jsbin.com/xefowokora/edit?html,css,js,output" target="_blank" rel="noopener">查看效果</a></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy对象是ES6新加进来的，原意是代理，js中用作代理器。<br>它主要用于改变某些操作的默认行为，等同于在语言层面做修改，所以属于一种”元编程（meta programming）”，即对编程语言进行编程，<br>它在目标对象的外层搭建了一层拦截，外界对目标对象的 某些操作，会通过这层拦截。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">具体用法戳这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handle = &#123;</span><br><span class="line">        get(obj, key,receiver) &#123;</span><br><span class="line">            return Reflect.get(obj,key,receiver)||222</span><br><span class="line">        &#125;,</span><br><span class="line">        set(obj, key, value,receiver) &#123;</span><br><span class="line">            Reflect.set(obj,key,value,receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tempObj=&#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">    let p = new Proxy(tempObj, handle)</span><br><span class="line"></span><br><span class="line">    console.log(p.a) // 1</span><br><span class="line">    console.log(p.b) // 222</span><br><span class="line">    p.c=111</span><br><span class="line">    console.log(tempObj.c) // 111</span><br></pre></td></tr></table></figure></li></ol><p>由以上代码中打印的tempObj.c=111，可知，实际在new Proxy的过程中，实例对象是对第一个参数对象的浅拷贝，但是这里对tempObj进行操作并不会触发get,set。</p><p>接下来用Proxy实现数据双向绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function proxyObserver(obj, setBind, getLogger) &#123;</span><br><span class="line">           if (!obj || typeof obj != &apos;object&apos;) &#123;</span><br><span class="line">               return</span><br><span class="line">           &#125;</span><br><span class="line">           const handle = &#123;</span><br><span class="line">               get(target, key, receiver) &#123;</span><br><span class="line">                   //receiver 为上下文this对象</span><br><span class="line">                  //getLogger()</span><br><span class="line">                   return Reflect.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">               &#125;,</span><br><span class="line">               set(target, key, value, receiver) &#123;</span><br><span class="line">                   // receiver 一般为proxy实例</span><br><span class="line">                   setBind(value, key)</span><br><span class="line">                   Reflect.set(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           Object.keys(obj).forEach(ele =&gt; &#123;</span><br><span class="line">               if (!!ele &amp;&amp; typeof ele === &apos;object&apos;) &#123;</span><br><span class="line">                   obj[ele] = proxyObserver(obj[ele], setBind, getLogger)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">           return new Proxy(obj, handle)</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/yuximidece/edit?html,css,js,output" target="_blank" rel="noopener">戳这里查看效果</a></p></blockquote><h2 id="对比优劣势"><a href="#对比优劣势" class="headerlink" title="对比优劣势"></a>对比优劣势</h2><p>从代码量上就能明显看出Proxy代码要少很多，实现简洁许多，两者相比优劣势如下:<br>Object.defineProperty：</p><ol><li>拦截的是对象的属性</li><li>无法监听数组变化</li><li>通过遍历对象属性修改，</li><li>兼容性较好IE9及以上</li></ol><p>Proxy:</p><ol><li>监听的是对象，而非某个属性</li><li>可以直接监听数组变化，</li><li>返回一个新对象（浅拷贝）</li><li>拦截方式多样，多达13种，除了get,set 还有apply、ownKeys、deleteProperty、has等。</li><li>兼容性较差 IE不支持</li></ol><h2 id="Compile-解析器"><a href="#Compile-解析器" class="headerlink" title="Compile 解析器"></a>Compile 解析器</h2><p>Compile的作用有两个，一个是解析指令初始化模板，另一个是添加订阅，绑定更新函数,这里只以v-modal为例<br>在解析的过程中会频繁操作DOM，所以用createDocumentFragment来保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">function Compile(context) &#123;</span><br><span class="line">            this.context = context;</span><br><span class="line">            this.el = context.$el;</span><br><span class="line">            this.fragment = null;</span><br><span class="line">            this.init();</span><br><span class="line">        &#125;</span><br><span class="line">        Compile.prototype = &#123;</span><br><span class="line">            init: function () &#123;</span><br><span class="line">                this.fragment = this.nodeFragment(this.el);</span><br><span class="line">            &#125;,</span><br><span class="line">            nodeFragment: function (el) &#123;</span><br><span class="line">                const fragment = document.createDocumentFragment();</span><br><span class="line">                let child = el.firstChild;</span><br><span class="line">                //将子节点，全部移动文档片段里</span><br><span class="line">                while (child) &#123;</span><br><span class="line">                    fragment.appendChild(child);</span><br><span class="line">                    child = el.firstChild;</span><br><span class="line">                &#125;</span><br><span class="line">                return fragment;</span><br><span class="line">            &#125;,</span><br><span class="line">            compileNode: function (fragment) &#123;</span><br><span class="line">                let childNodes = fragment.childNodes;</span><br><span class="line">                [...childNodes].forEach(node =&gt; &#123;</span><br><span class="line">                    let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">                    let text = node.textContent;</span><br><span class="line">                    if (this.isElementNode(node)) &#123;</span><br><span class="line">                        this.compile(node); //渲染指令模板</span><br><span class="line">                    &#125; else if (this.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">                        let prop = RegExp.$1;</span><br><span class="line">                        this.compileText(node, prop); //渲染&#123;&#123;&#125;&#125; 模板</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //递归编译子节点</span><br><span class="line">                    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                        this.compileNode(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            compile: function (node) &#123;</span><br><span class="line">                let nodeAttrs = node.attributes;</span><br><span class="line">                [...nodeAttrs].forEach(attr =&gt; &#123;</span><br><span class="line">                    let name = attr.name;</span><br><span class="line">                    if (this.isDirective(name)) &#123;</span><br><span class="line">                        let value = attr.value;</span><br><span class="line">                        if (name === &quot;v-model&quot;) &#123;</span><br><span class="line">                            this.compileModel(node, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        node.removeAttribute(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            //对所有子节点进行判断，1.初始化视图数据,2.绑定更新函数的订阅器</span><br><span class="line">            compileElement: function (el) &#123;</span><br><span class="line">                var childNodes = el.childNodes;</span><br><span class="line">                var self = this;</span><br><span class="line">                [].slice.call(childNodes).forEach(function (node) &#123;</span><br><span class="line">                    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; //匹配&quot; &#123;&#123;&#125;&#125; &quot;</span><br><span class="line">                    var text = node.textContent;</span><br><span class="line"></span><br><span class="line">                    if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; //判断&quot; &#123;&#123;&#125;&#125; &quot;</span><br><span class="line">                        self.compileText(node, reg.exec(text)[1]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                        self.compileElement(node); //// 继续递归遍历子节点</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            //初始化视图updateText和生成订阅器:</span><br><span class="line">            compileText: function (node, exp) &#123;</span><br><span class="line">                var self = this;</span><br><span class="line">                var initText = this.context[exp]; //代理访问self_vue.data.name1 -&gt; self_vue.name1</span><br><span class="line">                this.updateText(node, initText); //将初始化的数据初始化到视图中</span><br><span class="line">                new Watcher(this.context, exp, function (value) &#123; //&#123;&#125;，name, // 生成订阅器并绑定更新函数</span><br><span class="line">                    self.updateText(node, value);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            updateText: function (node, value) &#123;</span><br><span class="line">                node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class="line">            &#125;,</span><br><span class="line">            isTextNode: function (node) &#123;</span><br><span class="line">                return node.nodeType == 3; //文本节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据双向绑定，又叫数据响应式，就是数据（Model)和视图（View）保持同步，任何一边改变另一边也得到通知做相应的改变，常见的实现模式有M
      
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>我的树洞</title>
    <link href="http://yoursite.com/2020/04/08/algorithm/"/>
    <id>http://yoursite.com/2020/04/08/algorithm/</id>
    <published>2020-04-08T10:40:57.000Z</published>
    <updated>2020-04-08T10:40:57.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记一次字节面试经历"><a href="#记一次字节面试经历" class="headerlink" title="记一次字节面试经历"></a>记一次字节面试经历</h2><p>不紧张但是脑袋一点空白，总的来说不理想，写两到当时写的不好的代码题吧</p><p>1.实现trim函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正则实现</span><br><span class="line"> function trim(str) &#123;</span><br><span class="line">        let reg = /^\s+|\s+$/g</span><br><span class="line">        return str.replace(reg, &apos;&apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 数组实现</span><br><span class="line">   function arrTrim(str) &#123;</span><br><span class="line">        let list = str.split(&apos; &apos;)</span><br><span class="line"></span><br><span class="line">        function checkIndex(arr) &#123;</span><br><span class="line">            let start = arr.indexOf(&apos;&apos;)</span><br><span class="line">            let end = arr.lastIndexOf(&apos;&apos;)</span><br><span class="line">            return [start, end]</span><br><span class="line">        &#125;</span><br><span class="line">        let index = 0</span><br><span class="line">        </span><br><span class="line">        while (index &lt; list.length) &#123;</span><br><span class="line">            let [start, end] = checkIndex(list)</span><br><span class="line">            if (start == end) &#123;</span><br><span class="line">                if (start &gt; -1 &amp;&amp; end &gt; -1) &#123;</span><br><span class="line">                    list = list.splice(start + 1)</span><br><span class="line">                    continue</span><br><span class="line">                &#125;</span><br><span class="line">                if(start==-1&amp;&amp;end==-1)&#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                list = list.splice(start + 1, end - (start + 1))</span><br><span class="line">            &#125;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.join(&apos; &apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 字符串切割</span><br><span class="line"> function strTrim(str) &#123;</span><br><span class="line">        let index = 0</span><br><span class="line"></span><br><span class="line">        function checkIndex(s) &#123;</span><br><span class="line">            let start = s.indexOf(&apos; &apos;)</span><br><span class="line">            let end = s.lastIndexOf(&apos; &apos;)</span><br><span class="line">            return [start, end]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (index &lt; str.length) &#123;</span><br><span class="line">            let [start, end] = checkIndex(str)</span><br><span class="line">            if (start == end) &#123;</span><br><span class="line">                if ((start &gt; 0 &amp;&amp; end &lt; str.length) || start == -1 &amp;&amp; end == -1) &#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">                if (start &gt; -1 &amp;&amp; end &gt; -1) &#123;</span><br><span class="line">                    str = str.slice(start + 1)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                str = str.substr(start + 1, end - (start + 1))</span><br><span class="line">            &#125;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        return str</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.{‘a.b.c’:1}=&gt;{a:{b:{c:1}}}，这题一看就是个递归题，当时面试官说有没有用过reduce，然后我就掉沟里了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 数组实现</span><br><span class="line">    function parse(obj) &#123;</span><br><span class="line">        let result = &#123;&#125;</span><br><span class="line">        function subParse(key, val) &#123;</span><br><span class="line">            let keys = key.split(&apos;.&apos;)</span><br><span class="line"></span><br><span class="line">            function comb(obj, val) &#123;</span><br><span class="line">                let tempObj = &#123;&#125;</span><br><span class="line">                let keys = Object.keys(obj)</span><br><span class="line">                if (keys.length &gt; 0) &#123;</span><br><span class="line">                    tempObj[keys[0]] = comb(obj[keys[0]], val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    tempObj = val</span><br><span class="line">                &#125;</span><br><span class="line">                return tempObj</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return keys.reduce((cal, cur, i) =&gt; &#123;</span><br><span class="line">                let obj = &#123;&#125;</span><br><span class="line">                obj[cur] = i == keys.length - 1 ? val : &#123;&#125;</span><br><span class="line">                cal = comb(cal, obj)</span><br><span class="line">                return cal</span><br><span class="line">            &#125;, &#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let key in obj) &#123;</span><br><span class="line">            result = Object.assign(result, subParse(key, obj[key]))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">   </span><br><span class="line">    function fibParse(obj) &#123;</span><br><span class="line">        let result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        function subFib(key, val) &#123;</span><br><span class="line">        let temp = &#123;&#125;</span><br><span class="line">        let i = key.indexOf(&apos;.&apos;)</span><br><span class="line">        if (i &gt; -1) &#123;</span><br><span class="line">            let s = key.slice(0, i)</span><br><span class="line">            temp[s] = subFib(key.slice(i + 1), val)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">        return temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        for (let key in obj) &#123;</span><br><span class="line">            result = Object.assign(result, subFib(key, obj[key]))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记一次字节面试经历&quot;&gt;&lt;a href=&quot;#记一次字节面试经历&quot; class=&quot;headerlink&quot; title=&quot;记一次字节面试经历&quot;&gt;&lt;/a&gt;记一次字节面试经历&lt;/h2&gt;&lt;p&gt;不紧张但是脑袋一点空白，总的来说不理想，写两到当时写的不好的代码题吧&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="树洞" scheme="http://yoursite.com/categories/%E6%A0%91%E6%B4%9E/"/>
    
    
      <category term="树洞" scheme="http://yoursite.com/tags/%E6%A0%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://yoursite.com/2020/04/08/http/"/>
    <id>http://yoursite.com/2020/04/08/http/</id>
    <published>2020-04-08T05:46:47.000Z</published>
    <updated>2020-04-08T05:46:47.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议变化对比"><a href="#http协议变化对比" class="headerlink" title="http协议变化对比"></a>http协议变化对比</h2><p>HTTP全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层。<br>HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。</p><table border="1">    <tr align="center">      <th></th>        <th colspan="2">http/1.x</th>        <th>http/2.x</th>       <td>https</td>    </tr>    <tr>    <td></td>        <td>http/1.0</td>        <td>http/1.1</td>    </tr>     <tr>        <td>特点</td>        <td colspan="2">线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞</td>        <td>        1.采用二进制格式而非文本格式<br>        2.多路复用，而非有序并阻塞的、只需一个连接即可实现并行<br>        3.header压缩，降低开销<br>        4.服务器推送<br>        </td>        <td>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL）就成了https</td>    </tr>     <tr>        <td>缺陷</td>        <td>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器简历一个TCP连接（TCP连接的新建成本很高，因为需要客户端与服务器三次握手），服务器完成请求处理立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求</td>        <td>允许复用TCP连接，但同一个TCP连接里面所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求，如果前面的处理特别慢，后面就会有需求请求排队等待，这将导致对头堵塞</td>    </tr>    <tr>        <td>改进</td>        <td>解决方案 -- 添加头信息，非标准的Connection字段Connection: keep-alive</td>        <td>较少请求数量，同时多开持久连接</td>    </tr></table><h2 id="http1-x"><a href="#http1-x" class="headerlink" title="http1.x"></a>http1.x</h2><p> 影响一个HTTP网络请求的因素主要有两个：带宽和延迟</p><h3 id="一，带宽"><a href="#一，带宽" class="headerlink" title="一，带宽"></a>一，带宽</h3><p>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p><h3 id="二，延迟"><a href="#二，延迟" class="headerlink" title="二，延迟"></a>二，延迟</h3><p>1、浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>2、DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p><p>3、建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><p>http1.0对比http1.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、缓存处理，</span><br><span class="line">在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，</span><br><span class="line">HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line"></span><br><span class="line">2、带宽优化及网络连接的使用，</span><br><span class="line">HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，</span><br><span class="line">HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">3、错误通知的管理，</span><br><span class="line">在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</span><br><span class="line"></span><br><span class="line">4、Host头处理，</span><br><span class="line">在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），</span><br><span class="line">并且它们共享一个IP地址。</span><br><span class="line">HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</span><br><span class="line"></span><br><span class="line">5、长连接，</span><br><span class="line">HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，</span><br><span class="line">在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</span><br></pre></td></tr></table></figure><p>存在问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,每次传输数据都需要建立连接</span><br><span class="line">2，明文传输，一定程度上有安全隐患</span><br><span class="line">3，header里携带的内容过大，而且每次传输header基本不变，一定程度上增大了传输成本</span><br><span class="line">4，虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，</span><br><span class="line">   并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</span><br></pre></td></tr></table></figure><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>最初，HTTPS是与SSL一起使用的；在SSL逐渐演变到TLS时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。</p><p>简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在ios 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。</p><p>http与https的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</span><br><span class="line"></span><br><span class="line">2、HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</span><br><span class="line"></span><br><span class="line">3、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</span><br><span class="line"></span><br><span class="line">4、HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</span><br></pre></td></tr></table></figure><p>SPDY(speedy)协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。</span><br><span class="line">多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</span><br><span class="line"></span><br><span class="line">2、请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。</span><br><span class="line">SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，</span><br><span class="line">之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</span><br><span class="line"></span><br><span class="line">3、header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</span><br><span class="line"></span><br><span class="line">4、基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</span><br><span class="line"></span><br><span class="line">5、服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，</span><br><span class="line">服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了,</span><br><span class="line">SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能</span><br><span class="line"></span><br><span class="line"> http</span><br><span class="line">  ||</span><br><span class="line">  SPDY</span><br><span class="line">  ||</span><br><span class="line">  SSL</span><br><span class="line">  ||</span><br><span class="line">  TCP</span><br></pre></td></tr></table></figure><h2 id="HTTP2-X"><a href="#HTTP2-X" class="headerlink" title="HTTP2.X"></a>HTTP2.X</h2><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：<br>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS<br>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</p><p>新特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1,新的二进制格式（Binary Format）；</span><br><span class="line">http1.x是采用文本传输的，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，</span><br><span class="line">二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</span><br><span class="line">2，多路复用（MultiPlexing）</span><br><span class="line">即连接共享，即每一个request都适用连接共享机制。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，</span><br><span class="line">接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</span><br><span class="line">3,header压缩，</span><br><span class="line">HTTP1.x的header带有大量信息，而且每次都要重复发送，</span><br><span class="line">HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</span><br><span class="line">4，服务端推送（server push）</span><br><span class="line">同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用</span><br></pre></td></tr></table></figure><p>另外，<br>1、前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</p><p>2、当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南。</p><p>3、使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议变化对比&quot;&gt;&lt;a href=&quot;#http协议变化对比&quot; class=&quot;headerlink&quot; title=&quot;http协议变化对比&quot;&gt;&lt;/a&gt;http协议变化对比&lt;/h2&gt;&lt;p&gt;HTTP全称：超文本传输协议(HyperText Transfer Prot
      
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>单页应用与多页应用的区别</title>
    <link href="http://yoursite.com/2020/04/07/hello-world/"/>
    <id>http://yoursite.com/2020/04/07/hello-world/</id>
    <published>2020-04-07T03:00:12.633Z</published>
    <updated>2020-04-03T07:04:30.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA-SinglePage-Web-Application-单页应用"><a href="#SPA-SinglePage-Web-Application-单页应用" class="headerlink" title="SPA(SinglePage Web Application) 单页应用"></a>SPA(SinglePage Web Application) 单页应用</h2><ol><li>只有一个页面</li><li>路由跳转局部刷新</li></ol><h2 id="MPA-MultiPage-Application-多页应用"><a href="#MPA-MultiPage-Application-多页应用" class="headerlink" title="MPA(MultiPage Application) 多页应用"></a>MPA(MultiPage Application) 多页应用</h2><ol><li>页面跳转刷新所有资源</li><li>页面跳转整体刷新</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left"></th><th align="left">SPA</th><th align="left">MPA</th></tr></thead><tbody><tr><td align="left">应用组成</td><td align="left">一个外壳页面，多个子页面</td><td align="left">多个完整页面</td></tr><tr><td align="left">页面跳转</td><td align="left">子页面跳转，局部刷新</td><td align="left">跳转从一个页面到另一个页面，整体刷新</td></tr><tr><td align="left">页面跳转后公共资源重新加载</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">页面跳转动画</td><td align="left">可以实现</td><td align="left">不能实现</td></tr><tr><td align="left">页面间传值</td><td align="left">根据使用前端框架不同传值方式不同</td><td align="left">url,cookie,localStorage，web SQL等</td></tr><tr><td align="left">用户体验</td><td align="left">比较好，路由跳转快</td><td align="left">页面切换比较慢，用户体验较差</td></tr><tr><td align="left">搜索引擎优化（SEO）</td><td align="left">需要单独解决方案（如通过SSR服务端渲染的方式）</td><td align="left">实现简单</td></tr><tr><td align="left">应用场景</td><td align="left">流畅度，用户体验要求高的应用</td><td align="left">适用于对seo要求很高的应用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SPA-SinglePage-Web-Application-单页应用&quot;&gt;&lt;a href=&quot;#SPA-SinglePage-Web-Application-单页应用&quot; class=&quot;headerlink&quot; title=&quot;SPA(SinglePage Web App
      
    
    </summary>
    
      <category term="SPA" scheme="http://yoursite.com/categories/SPA/"/>
    
    
      <category term="SPA" scheme="http://yoursite.com/tags/SPA/"/>
    
  </entry>
  
  <entry>
    <title>div垂直水平居中，CSS2与CSS3实现</title>
    <link href="http://yoursite.com/2020/04/03/divCenter/"/>
    <id>http://yoursite.com/2020/04/03/divCenter/</id>
    <published>2020-04-03T07:51:41.000Z</published>
    <updated>2020-04-14T03:21:55.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS2"><a href="#CSS2" class="headerlink" title="CSS2"></a>CSS2</h2><p>通过给父这只设置display:table-cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure><p>给子盒子设置display：inline-block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: inline-block;</span><br><span class="line">vertical-align: middle;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/feqehigiju/edit?html,css,output" target="_blank" rel="noopener">查看示例</a></p></blockquote><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><ol><li>通过给父盒子设置position:relative<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;</span><br></pre></td></tr></table></figure></li></ol><p>给子盒子设置position:absolute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">transform: translate(-50%,-50%);</span><br><span class="line">margin-top: 50%;</span><br><span class="line">margin-left:50%</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/vacefubeji/edit?html,css,output" target="_blank" rel="noopener">查看示例</a></p></blockquote><ol start="2"><li>通过flex布局实现</li></ol><p>给父盒子设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/fejahoqexa/edit?html,css,output" target="_blank" rel="noopener">查看示例</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS2&quot;&gt;&lt;a href=&quot;#CSS2&quot; class=&quot;headerlink&quot; title=&quot;CSS2&quot;&gt;&lt;/a&gt;CSS2&lt;/h2&gt;&lt;p&gt;通过给父这只设置display:table-cell&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vueRouter 浅析</title>
    <link href="http://yoursite.com/2020/03/24/vueRouter/"/>
    <id>http://yoursite.com/2020/03/24/vueRouter/</id>
    <published>2020-03-24T08:57:59.000Z</published>
    <updated>2020-03-24T08:57:59.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着单页应用（SPA)的流行，前端路由也得以广泛应用，针对浏览器而言，前端路由有两种实现方式，hash和history。</p><h2 id="vue的第三方插件的install函数"><a href="#vue的第三方插件的install函数" class="headerlink" title="vue的第三方插件的install函数"></a>vue的第三方插件的install函数</h2><p> 先来看一下vue注册第三方插件<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(plugin)</span><br></pre></td></tr></table></figure></p><p> 这个注册机制就会调用plugin的install方法，来看一下vue-router的install ，src/install.js</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">        //首次进入初始化路由</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">          //根组件指向自己</span><br><span class="line">        this._routerRoot = this</span><br><span class="line">        this._router = this.$options.router</span><br><span class="line">        //初次进入对页面进行路由</span><br><span class="line">        this._router.init(this)</span><br><span class="line">        //监控 router数据变化，这里为更新router-view</span><br><span class="line">        Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //为每个组件传递根组件，方便访问router信息</span><br><span class="line">        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(this, this)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">//router访问的是根组件的router对象</span><br><span class="line">  Object.defineProperty(Vue.prototype, &apos;$router&apos;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">//route访问的是根组件的route对象</span><br><span class="line">  Object.defineProperty(Vue.prototype, &apos;$route&apos;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>拓展vue原型，添加全局属性$router和$route，混入beforeCreate和destroyed方法,</p></li><li><p>设置_routerRoot向上传递指向根组件，根组件设置router对象</p></li><li><p>根组件首次进入的时候，初始化路由，将router对象挂载到根组件元素_router上，并且设置劫持数据_route</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> export function install (Vue) &#123;</span><br><span class="line">  if (install.installed &amp;&amp; _Vue === Vue) return //如果已经注册过，直接返回避免重复注册</span><br><span class="line">  install.installed = true</span><br><span class="line">//私有化vue，方便引入</span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  const isDef = v =&gt; v !== undefined</span><br><span class="line"></span><br><span class="line">  const registerInstance = (vm, callVal) =&gt; &#123; // 注册vue-router实例</span><br><span class="line">    let i = vm.$options._parentVnode</span><br><span class="line">    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;RouterView&apos;, View)</span><br><span class="line">Vue.component(&apos;RouterLink&apos;, Link)</span><br><span class="line"></span><br><span class="line">const strats = Vue.config.optionMergeStrategies</span><br><span class="line">// use the same hook merging strategy for route hooks</span><br><span class="line">strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br></pre></td></tr></table></figure></li><li><p>注册RouterView和RouterLink组件</p></li></ul><h2 id="vue-router的实现"><a href="#vue-router的实现" class="headerlink" title="vue-router的实现"></a>vue-router的实现</h2><h3 id="vue-router实例-src-index-js"><a href="#vue-router实例-src-index-js" class="headerlink" title="vue-router实例 src/index.js"></a>vue-router实例 src/index.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">export default class VueRouter &#123;</span><br><span class="line">  static install: () =&gt; void;</span><br><span class="line">  static version: string;</span><br><span class="line"></span><br><span class="line">  app: any;</span><br><span class="line">  apps: Array&lt;any&gt;;</span><br><span class="line">  ready: boolean;</span><br><span class="line">  readyCbs: Array&lt;Function&gt;;</span><br><span class="line">  options: RouterOptions;</span><br><span class="line">  mode: string;</span><br><span class="line">  history: HashHistory | HTML5History | AbstractHistory;</span><br><span class="line">  matcher: Matcher;</span><br><span class="line">  fallback: boolean;</span><br><span class="line">  beforeHooks: Array&lt;?NavigationGuard&gt;;</span><br><span class="line">  resolveHooks: Array&lt;?NavigationGuard&gt;;</span><br><span class="line">  afterHooks: Array&lt;?AfterNavigationHook&gt;;</span><br><span class="line"></span><br><span class="line">  constructor (options: RouterOptions = &#123;&#125;) &#123;</span><br><span class="line">    this.app = null</span><br><span class="line">    this.apps = []</span><br><span class="line">    this.options = options</span><br><span class="line">    this.beforeHooks = []</span><br><span class="line">    this.resolveHooks = []</span><br><span class="line">    this.afterHooks = []</span><br><span class="line">    this.matcher = createMatcher(options.routes || [], this) //生成匹配表</span><br><span class="line">     // 路由模式设置默认hash</span><br><span class="line">    let mode = options.mode || &apos;hash&apos;</span><br><span class="line">    // 路由降级，如果不支持history降级到hash</span><br><span class="line">    this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false</span><br><span class="line">    if (this.fallback) &#123;</span><br><span class="line">      mode = &apos;hash&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 非浏览器环境</span><br><span class="line">    if (!inBrowser) &#123;</span><br><span class="line">      mode = &apos;abstract&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    this.mode = mode</span><br><span class="line"></span><br><span class="line">    switch (mode) &#123;</span><br><span class="line">      case &apos;history&apos;: //浏览器history模式</span><br><span class="line">        this.history = new HTML5History(this, options.base)</span><br><span class="line">        break</span><br><span class="line">      case &apos;hash&apos;: //浏览器hash模式</span><br><span class="line">        this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">        break</span><br><span class="line">      case &apos;abstract&apos;: //非浏览器环境</span><br><span class="line">        this.history = new AbstractHistory(this, options.base)</span><br><span class="line">        break</span><br><span class="line">      default:</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">          assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>上文提到 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.matcher = createMatcher(options.routes || [], this)</span><br></pre></td></tr></table></figure><p>我们来看看实现，src/create-matcher.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">export function createMatcher (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  router: VueRouter</span><br><span class="line">): Matcher &#123;</span><br><span class="line">  const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)</span><br><span class="line"></span><br><span class="line">  function addRoutes (routes) &#123;</span><br><span class="line">    createRouteMap(routes, pathList, pathMap, nameMap)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function match (</span><br><span class="line">    raw: RawLocation,</span><br><span class="line">    currentRoute?: Route,</span><br><span class="line">    redirectedFrom?: Location</span><br><span class="line">  ): Route &#123;</span><br><span class="line">    const location = normalizeLocation(raw, currentRoute, false, router)</span><br><span class="line">    const &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">    if (name) &#123;</span><br><span class="line">      const record = nameMap[name]</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        warn(record, `Route with name &apos;$&#123;name&#125;&apos; does not exist`)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!record) return _createRoute(null, location)</span><br><span class="line">      const paramNames = record.regex.keys</span><br><span class="line">        .filter(key =&gt; !key.optional)</span><br><span class="line">        .map(key =&gt; key.name)</span><br><span class="line"></span><br><span class="line">      if (typeof location.params !== &apos;object&apos;) &#123;</span><br><span class="line">        location.params = &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (currentRoute &amp;&amp; typeof currentRoute.params === &apos;object&apos;) &#123;</span><br><span class="line">        for (const key in currentRoute.params) &#123;</span><br><span class="line">          if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            location.params[key] = currentRoute.params[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location.path = fillParams(record.path, location.params, `named route &quot;$&#123;name&#125;&quot;`)</span><br><span class="line">      return _createRoute(record, location, redirectedFrom)</span><br><span class="line">    &#125; else if (location.path) &#123;</span><br><span class="line">      location.params = &#123;&#125;</span><br><span class="line">      for (let i = 0; i &lt; pathList.length; i++) &#123;</span><br><span class="line">        const path = pathList[i]</span><br><span class="line">        const record = pathMap[path]</span><br><span class="line">        if (matchRoute(record.regex, location.path, location.params)) &#123;</span><br><span class="line">          return _createRoute(record, location, redirectedFrom)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // no match</span><br><span class="line">    return _createRoute(null, location)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function redirect (</span><br><span class="line">    record: RouteRecord,</span><br><span class="line">    location: Location</span><br><span class="line">  ): Route &#123;</span><br><span class="line">    const originalRedirect = record.redirect</span><br><span class="line">    let redirect = typeof originalRedirect === &apos;function&apos;</span><br><span class="line">      ? originalRedirect(createRoute(record, location, null, router))</span><br><span class="line">      : originalRedirect</span><br><span class="line"></span><br><span class="line">    if (typeof redirect === &apos;string&apos;) &#123;</span><br><span class="line">      redirect = &#123; path: redirect &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!redirect || typeof redirect !== &apos;object&apos;) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      return _createRoute(null, location)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const re: Object = redirect</span><br><span class="line">    const &#123; name, path &#125; = re</span><br><span class="line">    let &#123; query, hash, params &#125; = location</span><br><span class="line">    query = re.hasOwnProperty(&apos;query&apos;) ? re.query : query</span><br><span class="line">    hash = re.hasOwnProperty(&apos;hash&apos;) ? re.hash : hash</span><br><span class="line">    params = re.hasOwnProperty(&apos;params&apos;) ? re.params : params</span><br><span class="line"></span><br><span class="line">    if (name) &#123;</span><br><span class="line">      // resolved named direct</span><br><span class="line">      const targetRecord = nameMap[name]</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        assert(targetRecord, `redirect failed: named route &quot;$&#123;name&#125;&quot; not found.`)</span><br><span class="line">      &#125;</span><br><span class="line">      return match(&#123;</span><br><span class="line">        _normalized: true,</span><br><span class="line">        name,</span><br><span class="line">        query,</span><br><span class="line">        hash,</span><br><span class="line">        params</span><br><span class="line">      &#125;, undefined, location)</span><br><span class="line">    &#125; else if (path) &#123;</span><br><span class="line">      // 1. resolve relative redirect</span><br><span class="line">      const rawPath = resolveRecordPath(path, record)</span><br><span class="line">      // 2. resolve params</span><br><span class="line">      const resolvedPath = fillParams(rawPath, params, `redirect route with path &quot;$&#123;rawPath&#125;&quot;`)</span><br><span class="line">      // 3. rematch with existing query and hash</span><br><span class="line">      return match(&#123;</span><br><span class="line">        _normalized: true,</span><br><span class="line">        path: resolvedPath,</span><br><span class="line">        query,</span><br><span class="line">        hash</span><br><span class="line">      &#125;, undefined, location)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        warn(false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;`)</span><br><span class="line">      &#125;</span><br><span class="line">      return _createRoute(null, location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function alias (</span><br><span class="line">    record: RouteRecord,</span><br><span class="line">    location: Location,</span><br><span class="line">    matchAs: string</span><br><span class="line">  ): Route &#123;</span><br><span class="line">    const aliasedPath = fillParams(matchAs, location.params, `aliased route with path &quot;$&#123;matchAs&#125;&quot;`)</span><br><span class="line">    const aliasedMatch = match(&#123;</span><br><span class="line">      _normalized: true,</span><br><span class="line">      path: aliasedPath</span><br><span class="line">    &#125;)</span><br><span class="line">    if (aliasedMatch) &#123;</span><br><span class="line">      const matched = aliasedMatch.matched</span><br><span class="line">      const aliasedRecord = matched[matched.length - 1]</span><br><span class="line">      location.params = aliasedMatch.params</span><br><span class="line">      return _createRoute(aliasedRecord, location)</span><br><span class="line">    &#125;</span><br><span class="line">    return _createRoute(null, location)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _createRoute (</span><br><span class="line">    record: ?RouteRecord,</span><br><span class="line">    location: Location,</span><br><span class="line">    redirectedFrom?: Location</span><br><span class="line">  ): Route &#123;</span><br><span class="line">    if (record &amp;&amp; record.redirect) &#123;</span><br><span class="line">      return redirect(record, redirectedFrom || location)</span><br><span class="line">    &#125;</span><br><span class="line">    if (record &amp;&amp; record.matchAs) &#123;</span><br><span class="line">      return alias(record, location, record.matchAs)</span><br><span class="line">    &#125;</span><br><span class="line">    return createRoute(record, location, redirectedFrom, router)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createMatcher再一次将routes配置数组传给了createRouteMap进一步处理,<br>根据代码分析createMatcher就是根据传入的routes生成路由map对应表，并且返回match函数以及一个可以增加路由配置项addRoutes函数，向上传递给VueRouter类暴露的接口addRoutes。</p><p>下面来看下createRouteMap  src/create-route-map.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">export function createRouteMap (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  oldPathList?: Array&lt;string&gt;,</span><br><span class="line">  oldPathMap?: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  oldNameMap?: Dictionary&lt;RouteRecord&gt;</span><br><span class="line">): &#123;</span><br><span class="line">  pathList: Array&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // the path list is used to control path matching priority</span><br><span class="line">  const pathList: Array&lt;string&gt; = oldPathList || [] //路径列表</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null) //path路由映射</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null) //name路由映射</span><br><span class="line"></span><br><span class="line">  routes.forEach(route =&gt; &#123;</span><br><span class="line">    addRouteRecord(pathList, pathMap, nameMap, route)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // ensure wildcard routes are always at the end</span><br><span class="line">  for (let i = 0, l = pathList.length; i &lt; l; i++) &#123;</span><br><span class="line">    if (pathList[i] === &apos;*&apos;) &#123;</span><br><span class="line">      pathList.push(pathList.splice(i, 1)[0])</span><br><span class="line">      l--</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">    // warn if routes do not include leading slashes</span><br><span class="line">    const found = pathList</span><br><span class="line">    // check for missing leading slash</span><br><span class="line">      .filter(path =&gt; path &amp;&amp; path.charAt(0) !== &apos;*&apos; &amp;&amp; path.charAt(0) !== &apos;/&apos;)</span><br><span class="line"></span><br><span class="line">    if (found.length &gt; 0) &#123;</span><br><span class="line">      const pathNames = found.map(path =&gt; `- $&#123;path&#125;`).join(&apos;\n&apos;)</span><br><span class="line">      warn(false, `Non-nested routes must include a leading slash character. Fix the following routes: \n$&#123;pathNames&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    pathList,</span><br><span class="line">    pathMap,</span><br><span class="line">    nameMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addRouteRecord (</span><br><span class="line">  pathList: Array&lt;string&gt;,  </span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;, </span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  route: RouteConfig,</span><br><span class="line">  parent?: RouteRecord,</span><br><span class="line">  matchAs?: string</span><br><span class="line">) &#123;</span><br><span class="line">  const &#123; path, name &#125; = route</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(path != null, `&quot;path&quot; is required in a route configuration.`)</span><br><span class="line">    assert(</span><br><span class="line">      typeof route.component !== &apos;string&apos;,</span><br><span class="line">      `route config &quot;component&quot; for path: $&#123;String(</span><br><span class="line">        path || name</span><br><span class="line">      )&#125; cannot be a ` + `string id. Use an actual component instead.`</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const pathToRegexpOptions: PathToRegexpOptions =</span><br><span class="line">    route.pathToRegexpOptions || &#123;&#125;</span><br><span class="line">  const normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict)</span><br><span class="line"></span><br><span class="line">  if (typeof route.caseSensitive === &apos;boolean&apos;) &#123;</span><br><span class="line">    pathToRegexpOptions.sensitive = route.caseSensitive</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const record: RouteRecord = &#123;</span><br><span class="line">    path: normalizedPath, //路径</span><br><span class="line">    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), //转化为匹配数组</span><br><span class="line">    components: route.components || &#123; default: route.component &#125;, // 关联组件</span><br><span class="line">    instances: &#123;&#125;,</span><br><span class="line">    name,</span><br><span class="line">    parent, // 父级router</span><br><span class="line">    matchAs,</span><br><span class="line">    redirect: route.redirect, // 跳转</span><br><span class="line">    beforeEnter: route.beforeEnter, // 进入前操作</span><br><span class="line">    meta: route.meta || &#123;&#125;, // 附加参数</span><br><span class="line">    props:</span><br><span class="line">      route.props == null</span><br><span class="line">        ? &#123;&#125;</span><br><span class="line">        : route.components</span><br><span class="line">          ? route.props</span><br><span class="line">          : &#123; default: route.props &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> // 子路由</span><br><span class="line">  if (route.children) &#123;</span><br><span class="line">    // Warn if route is named, does not redirect and has a default child route.</span><br><span class="line">    // If users navigate to this route by name, the default child will</span><br><span class="line">    // not be rendered (GH Issue #629)</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      if (</span><br><span class="line">        route.name &amp;&amp;</span><br><span class="line">        !route.redirect &amp;&amp;</span><br><span class="line">        route.children.some(child =&gt; /^\/?$/.test(child.path))</span><br><span class="line">      ) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          false,</span><br><span class="line">          `Named Route &apos;$&#123;route.name&#125;&apos; has a default child route. ` +</span><br><span class="line">            `When navigating to this named route (:to=&quot;&#123;name: &apos;$&#123;</span><br><span class="line">              route.name</span><br><span class="line">            &#125;&apos;&quot;), ` +</span><br><span class="line">            `the default child route will not be rendered. Remove the name from ` +</span><br><span class="line">            `this route and use the name of the default child route for named ` +</span><br><span class="line">            `links instead.`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 子路由收集</span><br><span class="line">    route.children.forEach(child =&gt; &#123;</span><br><span class="line">      const childMatchAs = matchAs</span><br><span class="line">        ? cleanPath(`$&#123;matchAs&#125;/$&#123;child.path&#125;`)</span><br><span class="line">        : undefined</span><br><span class="line">      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 按照路径存储</span><br><span class="line">  if (!pathMap[record.path]) &#123;</span><br><span class="line">    pathList.push(record.path)</span><br><span class="line">    pathMap[record.path] = record</span><br><span class="line">  &#125;</span><br><span class="line"> // 别名</span><br><span class="line">  if (route.alias !== undefined) &#123;</span><br><span class="line">    const aliases = Array.isArray(route.alias) ? route.alias : [route.alias]</span><br><span class="line">    for (let i = 0; i &lt; aliases.length; ++i) &#123;</span><br><span class="line">      const alias = aliases[i]</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; alias === path) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          false,</span><br><span class="line">          `Found an alias with the same value as the path: &quot;$&#123;path&#125;&quot;. You have to remove that alias. It will be ignored in development.`</span><br><span class="line">        )</span><br><span class="line">        // skip in dev to make it work</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const aliasRoute = &#123;</span><br><span class="line">        path: alias,</span><br><span class="line">        children: route.children</span><br><span class="line">      &#125;</span><br><span class="line">      addRouteRecord(</span><br><span class="line">        pathList,</span><br><span class="line">        pathMap,</span><br><span class="line">        nameMap,</span><br><span class="line">        aliasRoute,</span><br><span class="line">        parent,</span><br><span class="line">        record.path || &apos;/&apos; // matchAs</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// 按照名字存储</span><br><span class="line">  if (name) &#123;</span><br><span class="line">    if (!nameMap[name]) &#123;</span><br><span class="line">      nameMap[name] = record</span><br><span class="line">    &#125; else if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !matchAs) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        false,</span><br><span class="line">        `Duplicate named routes definition: ` +</span><br><span class="line">          `&#123; name: &quot;$&#123;name&#125;&quot;, path: &quot;$&#123;record.path&#125;&quot; &#125;`</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对router进行收集，通过path和name的方式存储，以便后期匹配。</p><h3 id="vueRouter构造函数"><a href="#vueRouter构造函数" class="headerlink" title="vueRouter构造函数"></a>vueRouter构造函数</h3><p> src/history/base.js<br>定义了路由的基本属性方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"> export class History &#123;</span><br><span class="line">  router: Router //路由对象</span><br><span class="line">  base: string // 基准路径</span><br><span class="line">  current: Route // 当前路由</span><br><span class="line">  pending: ?Route</span><br><span class="line">  cb: (r: Route) =&gt; void</span><br><span class="line">  ready: boolean</span><br><span class="line">  readyCbs: Array&lt;Function&gt;</span><br><span class="line">  readyErrorCbs: Array&lt;Function&gt;</span><br><span class="line">  errorCbs: Array&lt;Function&gt;</span><br><span class="line"></span><br><span class="line">  // implemented by sub-classes</span><br><span class="line">  +go: (n: number) =&gt; void</span><br><span class="line">  +push: (loc: RawLocation) =&gt; void</span><br><span class="line">  +replace: (loc: RawLocation) =&gt; void</span><br><span class="line">  +ensureURL: (push?: boolean) =&gt; void</span><br><span class="line">  +getCurrentLocation: () =&gt; string</span><br><span class="line"></span><br><span class="line">  constructor (router: Router, base: ?string) &#123;</span><br><span class="line">    this.router = router</span><br><span class="line">    // normalizeBase会对base路径做出格式化的处理，会为base开头自动添加‘/’，删除结尾的‘/’，默认返回’/‘</span><br><span class="line">    this.base = normalizeBase(base)</span><br><span class="line">    // start with a route object that stands for &quot;nowhere&quot;</span><br><span class="line">    this.current = START</span><br><span class="line">    this.pending = null</span><br><span class="line">    this.ready = false</span><br><span class="line">    this.readyCbs = []</span><br><span class="line">    this.readyErrorCbs = []</span><br><span class="line">    this.errorCbs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen (cb: Function) &#123;</span><br><span class="line">    this.cb = cb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onReady (cb: Function, errorCb: ?Function) &#123;</span><br><span class="line">    if (this.ready) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.readyCbs.push(cb)</span><br><span class="line">      if (errorCb) &#123;</span><br><span class="line">        this.readyErrorCbs.push(errorCb)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onError (errorCb: Function) &#123;</span><br><span class="line">    this.errorCbs.push(errorCb)</span><br><span class="line">  &#125;</span><br><span class="line"> // 路由转化操作</span><br><span class="line">  transitionTo (</span><br><span class="line">    location: RawLocation,</span><br><span class="line">    onComplete?: Function,</span><br><span class="line">    onAbort?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    const route = this.router.match(location, this.current) // 找到匹配的路由</span><br><span class="line">    this.confirmTransition( //确认是否转换</span><br><span class="line">      route,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        this.updateRoute(route) // 更新路由</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        this.ensureURL()</span><br><span class="line"></span><br><span class="line">        // fire ready cbs once</span><br><span class="line">        if (!this.ready) &#123;</span><br><span class="line">          this.ready = true</span><br><span class="line">          this.readyCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb(route)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        if (onAbort) &#123;</span><br><span class="line">          onAbort(err)</span><br><span class="line">        &#125;</span><br><span class="line">        if (err &amp;&amp; !this.ready) &#123;</span><br><span class="line">          this.ready = true</span><br><span class="line">          this.readyErrorCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) &#123;</span><br><span class="line">    const current = this.current</span><br><span class="line">    const abort = err =&gt; &#123;</span><br><span class="line">      // after merging https://github.com/vuejs/vue-router/pull/2771 we</span><br><span class="line">      // When the user navigates through history through back/forward buttons</span><br><span class="line">      // we do not want to throw the error. We only throw it if directly calling</span><br><span class="line">      // push/replace. That&apos;s why it&apos;s not included in isError</span><br><span class="line">      if (!isExtendedError(NavigationDuplicated, err) &amp;&amp; isError(err)) &#123;</span><br><span class="line">        if (this.errorCbs.length) &#123;</span><br><span class="line">          this.errorCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          warn(false, &apos;uncaught error during route navigation:&apos;)</span><br><span class="line">          console.error(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      onAbort &amp;&amp; onAbort(err)</span><br><span class="line">    &#125;</span><br><span class="line">        // 如果是同一个路由，不操作</span><br><span class="line">    if (</span><br><span class="line">      isSameRoute(route, current) &amp;&amp;</span><br><span class="line">      // in the case the route map has been dynamically appended to</span><br><span class="line">      route.matched.length === current.matched.length</span><br><span class="line">    ) &#123;</span><br><span class="line">      this.ensureURL()</span><br><span class="line">      return abort(new NavigationDuplicated(route))</span><br><span class="line">    &#125;</span><br><span class="line"> //钩子函数处理</span><br><span class="line">  </span><br><span class="line">    const &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">      this.current.matched,</span><br><span class="line">      route.matched</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    const queue: Array&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">      // in-component leave guards</span><br><span class="line">      extractLeaveGuards(deactivated),</span><br><span class="line">      // global before hooks</span><br><span class="line">      this.router.beforeHooks,</span><br><span class="line">      // in-component update hooks</span><br><span class="line">      extractUpdateHooks(updated),</span><br><span class="line">      // in-config enter guards</span><br><span class="line">      activated.map(m =&gt; m.beforeEnter),</span><br><span class="line">      // async components</span><br><span class="line">      resolveAsyncComponents(activated)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    this.pending = route</span><br><span class="line">    const iterator = (hook: NavigationGuard, next) =&gt; &#123;</span><br><span class="line">      if (this.pending !== route) &#123;</span><br><span class="line">        return abort()</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        hook(route, current, (to: any) =&gt; &#123;</span><br><span class="line">          if (to === false || isError(to)) &#123;</span><br><span class="line">            // next(false) -&gt; abort navigation, ensure current URL</span><br><span class="line">            this.ensureURL(true)</span><br><span class="line">            abort(to)</span><br><span class="line">          &#125; else if (</span><br><span class="line">            typeof to === &apos;string&apos; ||</span><br><span class="line">            (typeof to === &apos;object&apos; &amp;&amp;</span><br><span class="line">              (typeof to.path === &apos;string&apos; || typeof to.name === &apos;string&apos;))</span><br><span class="line">          ) &#123;</span><br><span class="line">            // next(&apos;/&apos;) or next(&#123; path: &apos;/&apos; &#125;) -&gt; redirect</span><br><span class="line">            abort()</span><br><span class="line">            if (typeof to === &apos;object&apos; &amp;&amp; to.replace) &#123;</span><br><span class="line">              this.replace(to)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.push(to)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // confirm transition and pass on the value</span><br><span class="line">            next(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        abort(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">      const postEnterCbs = []</span><br><span class="line">      const isValid = () =&gt; this.current === route</span><br><span class="line">      // wait until async components are resolved before</span><br><span class="line">      // extracting in-component enter guards</span><br><span class="line">      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">      const queue = enterGuards.concat(this.router.resolveHooks)</span><br><span class="line">      runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">        if (this.pending !== route) &#123;</span><br><span class="line">          return abort()</span><br><span class="line">        &#125;</span><br><span class="line">        this.pending = null</span><br><span class="line">        onComplete(route)</span><br><span class="line">        if (this.router.app) &#123;</span><br><span class="line">          this.router.app.$nextTick(() =&gt; &#123;</span><br><span class="line">            postEnterCbs.forEach(cb =&gt; &#123;</span><br><span class="line">              cb()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">// 更新路由</span><br><span class="line">  updateRoute (route: Route) &#123;</span><br><span class="line">    const prev = this.current //跳转前路由</span><br><span class="line">    this.current = route    //装备跳转路由</span><br><span class="line">    this.cb &amp;&amp; this.cb(route) //回调函数，这一步很重要，这个回调函数在index文件中注册，会更新被劫持的数据 _router</span><br><span class="line">    this.router.afterHooks.forEach(hook =&gt; &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 以上实现了history构造函数，定义了一些基础属性和方法，其中具体的路由实现方法，如下，需要具体的实现类去实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+go: (n: number) =&gt; void;</span><br><span class="line">+push: (loc: RawLocation) =&gt; void;</span><br><span class="line">+replace: (loc: RawLocation) =&gt; void;</span><br><span class="line">+ensureURL: (push?: boolean) =&gt; void;</span><br><span class="line">+getCurrentLocation: () =&gt; string;</span><br></pre></td></tr></table></figure><p>通过transitionTo对于路由更新的控制以及更新路由，updateRoute调用了我们在vue-router中注册的函数<br>src/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.listen(route =&gt; &#123;</span><br><span class="line">  this.apps.forEach((app) =&gt; &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这一步很重要，更新_route的值，还记得我们在install中做的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current)</span><br></pre></td></tr></table></figure><p>Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持了_route对象，这里路由更新_route,导致了视图更新。<br>Vue中看一下defineReactive的源码, 在defineReactive, 会对_route使用Object.defineProperty劫持setter方法。set时会通知观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get: function reactiveGetter () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function reactiveSetter (newVal) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">    dep.notify()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来看如何调用transitionTo，达到更新目的<br>来看一下hash的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export class HashHistory extends History &#123;</span><br><span class="line">  constructor (router: Router, base: ?string, fallback: boolean) &#123;</span><br><span class="line">    super(router, base)</span><br><span class="line">    // check history fallback deeplinking</span><br><span class="line">     // 如果是回退hash的情况，并且判断当前路径是否有/#/。如果没有将会添加&apos;/#/&apos;</span><br><span class="line">    if (fallback &amp;&amp; checkFallback(this.base)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    ensureSlash()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>checkFallback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 检查url是否包含‘/#/’</span><br><span class="line">function checkFallback (base) &#123;</span><br><span class="line">  // 获取hash值</span><br><span class="line">  const location = getLocation(base)</span><br><span class="line">  // 如果location不是以/#，开头。添加/#，使用window.location.replace替换文档</span><br><span class="line">  if (!/^\/#/.test(location)) &#123;</span><br><span class="line">    window.location.replace(</span><br><span class="line">      cleanPath(base + &apos;/#&apos; + location)</span><br><span class="line">    )</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回hash</span><br><span class="line">export function getLocation (base) &#123;</span><br><span class="line">  let path = decodeURI(window.location.pathname)</span><br><span class="line">  if (base &amp;&amp; path.indexOf(base) === 0) &#123;</span><br><span class="line">    path = path.slice(base.length)</span><br><span class="line">  &#125;</span><br><span class="line">  return (path || &apos;/&apos;) + window.location.search + window.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 删除 //, 替换为 /</span><br><span class="line">export function cleanPath (path) &#123;</span><br><span class="line">  return path.replace(/\/\//g, &apos;/&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用transitionTo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">//hash.js</span><br><span class="line">//设置路由，监控路由改变</span><br><span class="line">export class HashHistory extends History &#123;</span><br><span class="line">  constructor (router: Router, base: ?string, fallback: boolean) &#123;</span><br><span class="line">    super(router, base)</span><br><span class="line">    // check history fallback deeplinking</span><br><span class="line">    if (fallback &amp;&amp; checkFallback(this.base)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    ensureSlash()</span><br><span class="line">  &#125;</span><br><span class="line">  setupListeners () &#123;</span><br><span class="line">    window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123;</span><br><span class="line">      if (!ensureSlash()) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      this.transitionTo(getHash(), route =&gt; &#123;</span><br><span class="line">        replaceHash(route.fullPath)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> //push方法</span><br><span class="line">  push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      pushHash(route.fullPath)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">  //replace方法</span><br><span class="line">  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      replaceHash(route.fullPath)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  //html5.js实现</span><br><span class="line"></span><br><span class="line">export class HTML5History extends History &#123;</span><br><span class="line">  constructor (router: Router, base: ?string) &#123;</span><br><span class="line">    super(router, base)</span><br><span class="line"></span><br><span class="line">    const expectScroll = router.options.scrollBehavior //指回滚方式</span><br><span class="line"></span><br><span class="line">    if (expectScroll) &#123;</span><br><span class="line">      setupScroll()</span><br><span class="line">    &#125;</span><br><span class="line">    //监控popstate事件</span><br><span class="line">    window.addEventListener(&apos;popstate&apos;, e =&gt; &#123;</span><br><span class="line">      const current = this.current</span><br><span class="line">      this.transitionTo(getLocation(this.base), route =&gt; &#123;</span><br><span class="line">        if (expectScroll) &#123;</span><br><span class="line">          handleScroll(router, route, current, true)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //push</span><br><span class="line">   push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const &#123; current: fromRoute &#125; = this</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      pushState(cleanPath(this.base + route.fullPath)) //保存当前的位置信息，用于返回时候复位</span><br><span class="line">      handleScroll(this.router, route, fromRoute, false)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const &#123; current: fromRoute &#125; = this</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      replaceState(cleanPath(this.base + route.fullPath)) //保存当前的位置信息，用于返回时候复位</span><br><span class="line">      handleScroll(this.router, route, fromRoute, false)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //abstract.js实现，这里通过栈的数据结构来模拟路由路径</span><br><span class="line"> export class AbstractHistory extends History &#123;</span><br><span class="line">  index: number;</span><br><span class="line">  stack: Array&lt;Route&gt;;</span><br><span class="line"></span><br><span class="line">  constructor (router: Router, base: ?string) &#123;</span><br><span class="line">    super(router, base)</span><br><span class="line">    this.stack = []</span><br><span class="line">    this.index = -1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      this.stack = this.stack.slice(0, this.index + 1).concat(route)</span><br><span class="line">      this.index++</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      this.stack = this.stack.slice(0, this.index).concat(route)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，3种方式都提供了replace和push接口来更新路由同时hash模式监控 hashchange，H5模式监控 popstate</p><p>这里H5模式多了一步保存当前的位置信息，用于返回时候复位的操作</p><p>除了在子类调用之外，在 vueRouter类中init也有调用<br>src/index.js init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (history instanceof HTML5History) &#123;</span><br><span class="line">      history.transitionTo(history.getCurrentLocation())</span><br><span class="line">    &#125; else if (history instanceof HashHistory) &#123;</span><br><span class="line">      //建立hash监控</span><br><span class="line">      const setupHashListener = () =&gt; &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">      &#125;</span><br><span class="line">      history.transitionTo(</span><br><span class="line">        history.getCurrentLocation(),</span><br><span class="line">        setupHashListener,</span><br><span class="line">        setupHashListener</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在这hash和history模式下才有可能存在进入时候的不是默认页，需要根据当前浏览器地址栏里的 path 或者 hash 来激活对应的路由，此时就是通过调用 transitionTo 来达到目的<br>接着继续追踪replace和push的调用，这两个方法的触发通过我们定义的router-link组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;RouterLink&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    to: &#123;</span><br><span class="line">      type: toTypes,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    tag: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;a&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    exact: Boolean,</span><br><span class="line">    append: Boolean,</span><br><span class="line">    replace: Boolean,</span><br><span class="line">    activeClass: String,</span><br><span class="line">    exactActiveClass: String,</span><br><span class="line">    ariaCurrentValue: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;page&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    event: &#123;</span><br><span class="line">      type: eventTypes,</span><br><span class="line">      default: &apos;click&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h: Function) &#123;</span><br><span class="line">    const router = this.$router //路由对象</span><br><span class="line">    const current = this.$route //当前路由</span><br><span class="line">     //解析 to的路径对应路由项</span><br><span class="line">    const &#123; location, route, href &#125; = router.resolve(</span><br><span class="line">      this.to,</span><br><span class="line">      current,</span><br><span class="line">      this.append</span><br><span class="line">    )</span><br><span class="line">    //设置一些默认元素class</span><br><span class="line">    const classes = &#123;&#125;</span><br><span class="line">    const globalActiveClass = router.options.linkActiveClass</span><br><span class="line">    const globalExactActiveClass = router.options.linkExactActiveClass</span><br><span class="line">    // Support global empty active class</span><br><span class="line">    const activeClassFallback =</span><br><span class="line">      globalActiveClass == null ? &apos;router-link-active&apos; : globalActiveClass</span><br><span class="line">    const exactActiveClassFallback =</span><br><span class="line">      globalExactActiveClass == null</span><br><span class="line">        ? &apos;router-link-exact-active&apos;</span><br><span class="line">        : globalExactActiveClass</span><br><span class="line">    const activeClass =</span><br><span class="line">      this.activeClass == null ? activeClassFallback : this.activeClass</span><br><span class="line">    const exactActiveClass =</span><br><span class="line">      this.exactActiveClass == null</span><br><span class="line">        ? exactActiveClassFallback</span><br><span class="line">        : this.exactActiveClass</span><br><span class="line"></span><br><span class="line">    const compareTarget = route.redirectedFrom</span><br><span class="line">      ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)</span><br><span class="line">      : route</span><br><span class="line">    // 如果严格模式的话 就判断是否是相同路由（path query params hash）</span><br><span class="line">    // 否则就走包含逻辑（path包含，query包含 hash为空或者相同）</span><br><span class="line">    classes[exactActiveClass] = isSameRoute(current, compareTarget)</span><br><span class="line">    classes[activeClass] = this.exact</span><br><span class="line">      ? classes[exactActiveClass]</span><br><span class="line">      : isIncludedRoute(current, compareTarget)</span><br><span class="line"></span><br><span class="line">    const ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null</span><br><span class="line">    // 点击触发事件通过push或者replace更新路由</span><br><span class="line">    const handler = e =&gt; &#123;</span><br><span class="line">      if (guardEvent(e)) &#123;</span><br><span class="line">        if (this.replace) &#123;</span><br><span class="line">          router.replace(location, noop)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          router.push(location, noop)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const on = &#123; click: guardEvent &#125;</span><br><span class="line">    if (Array.isArray(this.event)) &#123;</span><br><span class="line">      this.event.forEach(e =&gt; &#123;</span><br><span class="line">        on[e] = handler</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      on[this.event] = handler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const data: any = &#123; class: classes &#125;</span><br><span class="line"></span><br><span class="line">    const scopedSlot =</span><br><span class="line">      !this.$scopedSlots.$hasNormal &amp;&amp;</span><br><span class="line">      this.$scopedSlots.default &amp;&amp;</span><br><span class="line">      this.$scopedSlots.default(&#123;</span><br><span class="line">        href,</span><br><span class="line">        route,</span><br><span class="line">        navigate: handler,</span><br><span class="line">        isActive: classes[activeClass],</span><br><span class="line">        isExactActive: classes[exactActiveClass]</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    if (scopedSlot) &#123;</span><br><span class="line">      if (scopedSlot.length === 1) &#123;</span><br><span class="line">        return scopedSlot[0]</span><br><span class="line">      &#125; else if (scopedSlot.length &gt; 1 || !scopedSlot.length) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            false,</span><br><span class="line">            `RouterLink with to=&quot;$&#123;</span><br><span class="line">              this.to</span><br><span class="line">            &#125;&quot; is trying to use a scoped slot but it didn&apos;t provide exactly one child. Wrapping the content with a span element.`</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        return scopedSlot.length === 0 ? h() : h(&apos;span&apos;, &#123;&#125;, scopedSlot)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.tag === &apos;a&apos;) &#123;</span><br><span class="line">      data.on = on</span><br><span class="line">      // aria-current设置当前激活页</span><br><span class="line">      </span><br><span class="line">      data.attrs = &#123; href, &apos;aria-current&apos;: ariaCurrentValue &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // find the first &lt;a&gt; child and apply listener and href</span><br><span class="line">      const a = findAnchor(this.$slots.default)</span><br><span class="line">      if (a) &#123;</span><br><span class="line">        // in case the &lt;a&gt; is a static node</span><br><span class="line">        a.isStatic = false</span><br><span class="line">        const aData = (a.data = extend(&#123;&#125;, a.data))</span><br><span class="line">        aData.on = aData.on || &#123;&#125;</span><br><span class="line">        // transform existing events in both objects into arrays so we can push later</span><br><span class="line">        for (const event in aData.on) &#123;</span><br><span class="line">          const handler = aData.on[event]</span><br><span class="line">          if (event in on) &#123;</span><br><span class="line">            aData.on[event] = Array.isArray(handler) ? handler : [handler]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // append new listeners for router-link</span><br><span class="line">        for (const event in on) &#123;</span><br><span class="line">          if (event in aData.on) &#123;</span><br><span class="line">            // on[event] is always a function</span><br><span class="line">            aData.on[event].push(on[event])</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            aData.on[event] = handler</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const aAttrs = (a.data.attrs = extend(&#123;&#125;, a.data.attrs))</span><br><span class="line">        aAttrs.href = href</span><br><span class="line">        aAttrs[&apos;aria-current&apos;] = ariaCurrentValue</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // doesn&apos;t have &lt;a&gt; child, apply listener to self</span><br><span class="line">        data.on = on</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(this.tag, data, this.$slots.default)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function guardEvent (e) &#123;</span><br><span class="line">  // don&apos;t redirect with control keys</span><br><span class="line">  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return</span><br><span class="line">  // don&apos;t redirect when preventDefault called</span><br><span class="line">  if (e.defaultPrevented) return</span><br><span class="line">  // don&apos;t redirect on right click</span><br><span class="line">  if (e.button !== undefined &amp;&amp; e.button !== 0) return</span><br><span class="line">  // don&apos;t redirect if `target=&quot;_blank&quot;`</span><br><span class="line">  if (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) &#123;</span><br><span class="line">    const target = e.currentTarget.getAttribute(&apos;target&apos;)</span><br><span class="line">    if (/\b_blank\b/i.test(target)) return</span><br><span class="line">  &#125;</span><br><span class="line">  // this may be a Weex event which doesn&apos;t have this method</span><br><span class="line">  if (e.preventDefault) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到第一个A标签</span><br><span class="line">function findAnchor (children) &#123;</span><br><span class="line">  if (children) &#123;</span><br><span class="line">    let child</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i]</span><br><span class="line">      if (child.tag === &apos;a&apos;) &#123;</span><br><span class="line">        return child</span><br><span class="line">      &#125;</span><br><span class="line">      if (child.children &amp;&amp; (child = findAnchor(child.children))) &#123;</span><br><span class="line">        return child</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下router-view<br>RouterView是可以互相嵌套的，RouterView依赖了parent.route属性，parent.route即this._routerRoot._route。<br>我们使用Vue.util.defineReactive将_router设置为响应式的。在transitionTo的回调中会更新_route, 这会触发RouteView的渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;RouterView&apos;,</span><br><span class="line">  functional: true, //函数组件</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;default&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (_, &#123; props, children, parent, data &#125;) &#123;</span><br><span class="line">    // used by devtools to display a router-view badge</span><br><span class="line">    data.routerView = true</span><br><span class="line"></span><br><span class="line">    // directly use parent context&apos;s createElement() function</span><br><span class="line">    // so that components rendered by router-view can resolve named slots</span><br><span class="line">    const h = parent.$createElement</span><br><span class="line">    const name = props.name</span><br><span class="line">    const route = parent.$route</span><br><span class="line">    const cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    // determine current view depth, also check to see if the tree</span><br><span class="line">    // has been toggled inactive but kept-alive.</span><br><span class="line">    let depth = 0</span><br><span class="line">    let inactive = false</span><br><span class="line">     // 使用while循环找到Vue的根节点, _routerRoot是Vue的根实例</span><br><span class="line">    // depth为当前的RouteView的深度，因为RouteView可以互相嵌套，depth可以帮组我们找到每一级RouteView需要渲染的组件</span><br><span class="line">    while (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">      const vnodeData = parent.$vnode ? parent.$vnode.data : &#123;&#125;</span><br><span class="line">      if (vnodeData.routerView) &#123;</span><br><span class="line">        depth++</span><br><span class="line">      &#125;</span><br><span class="line">      if (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) &#123;</span><br><span class="line">        inactive = true</span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    data.routerViewDepth = depth</span><br><span class="line"></span><br><span class="line">    // render previous view if the tree is inactive and kept-alive</span><br><span class="line">    if (inactive) &#123;</span><br><span class="line">      const cachedData = cache[name]</span><br><span class="line">      const cachedComponent = cachedData &amp;&amp; cachedData.component</span><br><span class="line">      if (cachedComponent) &#123;</span><br><span class="line">        // #2301</span><br><span class="line">        // pass props</span><br><span class="line">        if (cachedData.configProps) &#123;</span><br><span class="line">          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps)</span><br><span class="line">        &#125;</span><br><span class="line">        return h(cachedComponent, data, children)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // render previous empty view</span><br><span class="line">        return h()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const matched = route.matched[depth]</span><br><span class="line">    const component = matched &amp;&amp; matched.components[name]</span><br><span class="line"></span><br><span class="line">    // render empty node if no matched route or no config component</span><br><span class="line">    if (!matched || !component) &#123;</span><br><span class="line">      cache[name] = null</span><br><span class="line">      return h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // cache component</span><br><span class="line">    cache[name] = &#123; component &#125;</span><br><span class="line"></span><br><span class="line">    // attach instance registration hook</span><br><span class="line">    // this will be called in the instance&apos;s injected lifecycle hooks</span><br><span class="line">    data.registerRouteInstance = (vm, val) =&gt; &#123;</span><br><span class="line">      // val could be undefined for unregistration</span><br><span class="line">      const current = matched.instances[name]</span><br><span class="line">      if (</span><br><span class="line">        (val &amp;&amp; current !== vm) ||</span><br><span class="line">        (!val &amp;&amp; current === vm)</span><br><span class="line">      ) &#123;</span><br><span class="line">        matched.instances[name] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // also register instance in prepatch hook</span><br><span class="line">    // in case the same component instance is reused across different routes</span><br><span class="line">    ;(data.hook || (data.hook = &#123;&#125;)).prepatch = (_, vnode) =&gt; &#123;</span><br><span class="line">      matched.instances[name] = vnode.componentInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // register instance in init hook</span><br><span class="line">    // in case kept-alive component be actived when routes changed</span><br><span class="line">    data.hook.init = (vnode) =&gt; &#123;</span><br><span class="line">      if (vnode.data.keepAlive &amp;&amp;</span><br><span class="line">        vnode.componentInstance &amp;&amp;</span><br><span class="line">        vnode.componentInstance !== matched.instances[name]</span><br><span class="line">      ) &#123;</span><br><span class="line">        matched.instances[name] = vnode.componentInstance</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const configProps = matched.props &amp;&amp; matched.props[name]</span><br><span class="line">    // save route and configProps in cachce</span><br><span class="line">    if (configProps) &#123;</span><br><span class="line">      extend(cache[name], &#123;</span><br><span class="line">        route,</span><br><span class="line">        configProps</span><br><span class="line">      &#125;)</span><br><span class="line">      fillPropsinData(component, data, route, configProps)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fillPropsinData (component, data, route, configProps) &#123;</span><br><span class="line">  // resolve props</span><br><span class="line">  let propsToPass = data.props = resolveProps(route, configProps)</span><br><span class="line">  if (propsToPass) &#123;</span><br><span class="line">    // clone to prevent mutation</span><br><span class="line">    propsToPass = data.props = extend(&#123;&#125;, propsToPass)</span><br><span class="line">    // pass non-declared props as attrs</span><br><span class="line">    const attrs = data.attrs = data.attrs || &#123;&#125;</span><br><span class="line">    for (const key in propsToPass) &#123;</span><br><span class="line">      if (!component.props || !(key in component.props)) &#123;</span><br><span class="line">        attrs[key] = propsToPass[key]</span><br><span class="line">        delete propsToPass[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function resolveProps (route, config) &#123;</span><br><span class="line">  switch (typeof config) &#123;</span><br><span class="line">    case &apos;undefined&apos;:</span><br><span class="line">      return</span><br><span class="line">    case &apos;object&apos;:</span><br><span class="line">      return config</span><br><span class="line">    case &apos;function&apos;:</span><br><span class="line">      return config(route)</span><br><span class="line">    case &apos;boolean&apos;:</span><br><span class="line">      return config ? route.params : undefined</span><br><span class="line">    default:</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          false,</span><br><span class="line">          `props in &quot;$&#123;route.path&#125;&quot; is a $&#123;typeof config&#125;, ` +</span><br><span class="line">          `expecting an object, function or boolean.`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>安装插件<br>完成了router-link和 router-view 两个组件的注册，router-link用于触发路由的变化，router-view作为功能组件，用于触发对应路由视图的变化<br>　混入beforeCreate生命周期处理，初始化_routerRoot，_router，_route等数据<br>　全局设置VUE静态访问$router和$route，方便后期访问</li><li>根据路由配置生成router实例<br>根据配置数组生成路由配置记录表<br>　生成监控路由变化的hsitory对象</li><li>将router实例传入根VUE实例<br>根据beforeCreate混入，为根vue对象设置了劫持字段_route，用户触发router-view的变化<br>　调用init()函数，完成首次路由的渲染，首次渲染的调用路径是 调用history.transitionTo方法，根据router的match函数，生成一个新的route对象，<br>接着通过confirmTransition对比一下新生成的route和当前的route对象 是否改变，改变的话触发updateRoute，更新hsitory.current属性，触发根组件的_route的变化,<br>从而导致组件的调用render函数，更新router-view。<br>　另外一种更新路由的方式是主动触发，router-link绑定了click方法，触发history.push或者history.replace,从而触发history.transitionTo<br>　同时会监控hashchange和popstate来对路由变化作对用的处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着单页应用（SPA)的流行，前端路由也得以广泛应用，针对浏览器而言，前端路由有两种实现方式，hash和history。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
      <category term="vue-router" scheme="http://yoursite.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>VUE HOC 小结</title>
    <link href="http://yoursite.com/2020/03/23/HOC/"/>
    <id>http://yoursite.com/2020/03/23/HOC/</id>
    <published>2020-03-23T02:47:24.000Z</published>
    <updated>2020-03-23T08:18:35.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HOC(Higher Order Component)高阶组件，说到高阶组件，你可能会想到高阶函数，是的，他们是很类似的。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p> 什么是高阶函数呢？记得设计模式书中是这样定义的：函数作为参数传递，或返回值是一个函数的函数就是高阶函数</p><p>1.函数作为参数的例子很多，比如我们平时用到数组方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj= [1, 2, 3].reduce((current, value, index, arr) =&gt; &#123;</span><br><span class="line">    current[value] = value</span><br><span class="line">    return current</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line">// obj &#123;1:1,2:2,3:3&#125;</span><br></pre></td></tr></table></figure><p>2,函数作为值返回,闭包是一个典型的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addFn() &#123;</span><br><span class="line">      const baseNum = 5</span><br><span class="line">      return function (num) &#123;</span><br><span class="line">          return baseNum + num</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p> 既然高阶组件跟高阶函数类型，那么就可以类比出它的定义<br> 1，组件作为参数<br> 2，组件作为值返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export default function Hoc(subComponent) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            subComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        render(h) &#123;</span><br><span class="line">            return h(&apos;subComponent&apos;, &#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    ...this.$attrs,</span><br><span class="line">                    &apos;other-props&apos;: &apos;other-props&apos;,</span><br><span class="line">                &#125;,</span><br><span class="line">                on: &#123;</span><br><span class="line">                    ...this.$listeners</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>template写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function Hoc(subComponent) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        template:&apos;&lt;wrapComponent v-on=&quot;$listeners&quot; v-bind=&quot;$attrs&quot;/&gt;&apos;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            wrapComponent:subComponent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了$attrs,$listeners传递属性和事件。</p><hr><p>关于$attrs, 是用来传递props的属性，例如爷爷组件想要传递属性给孙子组件，但是在父组件中无需出现，就可以用到，<br>值得注意的是，爷爷组件传递的属性，父组件的的props声明接收的属性，通过$attrs将不会传递给孙子组件。<br>另外，父组件设置inheritAttrs：true,可以不将props未声明的属性作用在父组件上</p><p>$listeners就是将爷爷组件绑定到父组件上的事件传递给孙子组件，孙子组件直接通过this.$emit触发。</p><hr><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>实际上高阶组件(HOC)是react提高组件复用的一种实现，在vue中是通过mixins实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// mixinsComponent.vue</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &apos;mixinsComponent&apos;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                num: 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            console.log(&apos;mixinsComponent&apos;)</span><br><span class="line">            console.log(this.num) //1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import mixinsComponent from &quot;./mixinsComponent&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;componentA&apos;,</span><br><span class="line">    mixins: [mixinsComponent],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(&apos;componentA&apos;)</span><br><span class="line">        console.log(++this.num) // 访问mixinsComponent中的num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="minxins特点"><a href="#minxins特点" class="headerlink" title="minxins特点"></a>minxins特点</h3><ul><li><p>共用属性</p><p>共用属性指是在mixinsComponent组件中声明的属性和事件，在mixins之后，进行minxin的组件都可以访问到，如上例，componentA可以放到mixinsComponent中生命的num.</p></li><li><p>互不影响<br>一旦minxins之后，通过当前组件修改mixinsComponent里面声明的属性值，不会影响到其他引用mixinsComponent进行minxins的组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import mixinsComponent from &quot;./mixinsComponent&quot;</span><br><span class="line"> export default &#123;</span><br><span class="line">     name:&apos;componentB&apos;,</span><br><span class="line">     mixins: [mixinsComponent],</span><br><span class="line">     created()&#123;</span><br><span class="line">        console.log(&apos;componentB&apos;)</span><br><span class="line">        console.log(this.num) // 访问mixinsComponent中的num,值是1，</span><br><span class="line">                              //不管componentA是否有修改mixinsComponent里的num</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>值为函数的选项，如created,mounted等，就会被合并调用，混合组件里的钩子函数在当前组件里的钩子函数之前调用</p><p>以componentA为例打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mixinsComponent</span><br><span class="line">1</span><br><span class="line">componentA</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li></ul><h2 id="react高阶组件"><a href="#react高阶组件" class="headerlink" title="react高阶组件"></a>react高阶组件</h2><p>react起初也是通过mixins实现组件复用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var wellMixin = &#123;</span><br><span class="line">    componentWillMount: function () &#123;</span><br><span class="line">        console.log(&apos;Component will mount&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount: function () &#123;</span><br><span class="line">        console.log(&apos;Component did mount&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var AComponent = React.createClass(&#123;</span><br><span class="line">    mixins: [wellMixin],</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;AComponent&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后由于react的设计模式，mixins并不是好的解决办法，于是出现了高阶组件</p><blockquote><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method" target="_blank" rel="noopener">react文档</a></p></blockquote><p>特点：<br>1.高阶组件的生命周期不会影响传入的组件<br>2.并不是高阶组件的所有生命周期都会先执行,所以在使用高阶组件需要用到生命周期钩子时这里需要注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">export var IntervalEnhance = ComposeComponent =&gt; class extends ComposeComponent &#123;</span><br><span class="line">    // 2</span><br><span class="line">    static displayName = &apos;ComponentEnhancedWithIntervalHOC&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            seconds: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.interval = setInterval(this.tick.bind(this), 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        clearInterval(this.interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tick() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            seconds: this.state.seconds + 1000</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            // 4</span><br><span class="line">            &lt;ComposeComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">// 1</span><br><span class="line">import &#123;IntervalEnhance&#125; from &apos;./IntervalEnhance&apos;;</span><br><span class="line"></span><br><span class="line">class CartItem extends React.Component &#123;</span><br><span class="line">    //...略...</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">export default IntervalEnhance(CartItem);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>高阶组件就是，参数为组件，返回值为新组件的函数。<br>通过高阶组件可以对组件进行拓展，实现高复用<br>vue中通过mixins实现组件拓展，值为函数的选项，如created,mounted等，就会被合并调用，混合组件里的钩子函数在当前组件里的钩子函数之前调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;HOC(Higher Order Component)高阶组件，说到高阶组件，你可能会想到高阶函数，是的，他们是很类似的。&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>vue jsx语法创建form表单小记</title>
    <link href="http://yoursite.com/2020/03/23/createForm/"/>
    <id>http://yoursite.com/2020/03/23/createForm/</id>
    <published>2020-03-23T01:47:24.000Z</published>
    <updated>2020-03-23T08:18:32.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>后台管理系统大量用到表单，所以对表单进行了封装基于iview-ui .起初是使用template的方式，随着需求越来越多，template非常的臃肿，于是需要进行改造，让代码看起来更优雅简洁，</p><h3 id="使用render函数改造"><a href="#使用render函数改造" class="headerlink" title="使用render函数改造"></a>使用render函数改造</h3><p>一开始首先想到的就是利用vue的render函数，话不多说上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">inputRender (item, createElement) &#123;</span><br><span class="line">  const &#123;disabled, placeholder, clear&#125; = item</span><br><span class="line">  return createElement(&apos;Input&apos;, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: this.formList[key],</span><br><span class="line">      placeholder: this.$t(placeholder),</span><br><span class="line">      clearable: clear,</span><br><span class="line">      type: &apos;text&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    class: [&apos;row-form-item&apos;, &apos;radius_border&apos;],</span><br><span class="line">    on: &#123;</span><br><span class="line">      input: (val) =&gt; &#123;</span><br><span class="line">        this.formList[key] = val</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;on-change&apos;: (event) =&gt; &#123;</span><br><span class="line">        this.$emit(&apos;change-input-handle&apos;, this.formList[key], item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但是render需要手动去实现双向绑定，如上代码，监听input事件进行赋值，这样虽然实现了数据的双向绑定，但是formItem的表单校验却不能通过，因为表单校验获取的数据中formItem的fieldValue没有值，这个赋值是iview内部的双向绑定实现的，所以自己实现的双向绑定不会触发iview内部的事件。</p><p>改用jsx实现创建 ，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inputRender (item, createElement) &#123;</span><br><span class="line">  const &#123;disabled, placeholder, clear&#125; = item</span><br><span class="line">  return (&lt;Input v-model=&#123;this.formList[key]&#125;</span><br><span class="line">    size= &#123;size || &apos;default&apos;&#125;</span><br><span class="line">    placeholder=&#123;this.$t(placeholder)&#125;</span><br><span class="line">    clearable=&#123;clear&#125;</span><br><span class="line">    type =&apos;text&apos;</span><br><span class="line">    class=&apos;row-form-item&apos;</span><br><span class="line">    on-on-change=&#123;(val) =&gt; &#123;</span><br><span class="line">      this.$emit(&apos;change-input-handle&apos;, val, item)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;/Input&gt;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以直接使用v-modal实现双向绑定，所以表单校验可以正常通过。</p><hr><h2 id="jsx-使用"><a href="#jsx-使用" class="headerlink" title="jsx 使用"></a>jsx 使用</h2><p>使用jsx语法，需要使用babel：transform-vue-jsx ；<br>使用jsx语法，如果需要用到v-modal，使用babel:jsx-v-model;<br>绑定事件使用 on-打头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on-on-change=&#123;(val) =&gt; &#123;</span><br><span class="line">         this.$emit(&apos;change-input-handle&apos;, val, item)</span><br><span class="line">       &#125;&#125;</span><br></pre></td></tr></table></figure><p>由于iview的input change事件是on-change如果jsx语法绑定事件在前面加一个on。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;后台管理系统大量用到表单，所以对表单进行了封装基于iview-ui .起初是使用template的方式，随着需求越来越多，template非
      
    
    </summary>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="http://yoursite.com/2020/03/23/css/"/>
    <id>http://yoursite.com/2020/03/23/css/</id>
    <published>2020-03-23T01:46:31.000Z</published>
    <updated>2020-03-23T08:18:30.212Z</updated>
    
    <content type="html"><![CDATA[<p>css简单整理</p><hr><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><ul><li>Grid网格布局</li></ul><blockquote><p>本文引自阮一峰的网络日志： <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p></blockquote><p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>学习 Grid 布局之前，需要了解一些基本概念。</p><p>1.容器和项目</p><hr><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。</span><br></pre></td></tr></table></figure><p>2.行和列</p><hr><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><p>3.单元格</p><hr><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。</p><p>4.网格线</p><hr><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。</p><h3 id="二、容器属性"><a href="#二、容器属性" class="headerlink" title="二、容器属性"></a>二、容器属性</h3><hr><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><ol><li>display属性</li></ol><hr><p>display: grid指定一个容器采用网格布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    display:inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定div是一个行内元素，该元素内部采用网格布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</span><br></pre></td></tr></table></figure><p>2.grid-template-columns 属性，<br>  grid-template-rows 属性</p><hr><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 33.33% 33.33% 33.33%;</span><br><span class="line">  grid-template-rows: 33.33% 33.33% 33.33%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/yuzupej/2/edit?html,css,output" target="_blank" rel="noopener">点击这个查看示例</a></p></blockquote><p><strong>(1)repeat()</strong></p><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 33.33%);</span><br><span class="line">  grid-template-rows: repeat(3, 33.33%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p>repeat()重复某种模式也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: repeat(2, 100px 20px 80px);</span><br></pre></td></tr></table></figure><p><strong>（2）auto-fill 关键字</strong></p><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。</p><p><strong>（3）fr 关键字</strong></p><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 1fr 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fr可以与绝对长度的单位结合使用，这时会非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><strong>（4）minmax()</strong></p><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 1fr 1fr minmax(100px, 1fr);</span><br></pre></td></tr></table></figure><p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p><p><strong>（5）auto 关键字</strong></p><p>auto关键字表示由浏览器自己决定长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px;</span><br></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p><p><strong>（6）网格线的名称</strong></p><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如[fifth-line row-5]。</p><p><strong>（7）布局实例</strong></p><p>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 70% 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: repeat(12, 1fr);</span><br></pre></td></tr></table></figure><p>3.grid-row-gap 属性，<br>  grid-column-gap 属性，<br>  grid-gap 属性</p><hr><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-row-gap: 20px;</span><br><span class="line">  grid-column-gap: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。</p><blockquote><p><a href="https://jsbin.com/yuzupej/edit?html,css,output" target="_blank" rel="noopener">查看示例</a></p></blockquote><p>grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br></pre></td></tr></table></figure><p>因此，上面一段 CSS 代码等同于下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-gap: 20px 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</span><br></pre></td></tr></table></figure><p>4.grid-template-areas 属性</p><hr><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &apos;a b c&apos;</span><br><span class="line">                       &apos;d e f&apos;</span><br><span class="line">                       &apos;g h i&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &apos;a a a&apos;</span><br><span class="line">                     &apos;b b b&apos;</span><br><span class="line">                     &apos;c c c&apos;;</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。</p><p>下面是一个布局实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">                     &quot;main main sidebar&quot;</span><br><span class="line">                     &quot;footer footer footer&quot;;</span><br><span class="line">```                     </span><br><span class="line">上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</span><br><span class="line"></span><br><span class="line">如果某些区域不需要利用，则使用&quot;点&quot;（.）表示。</span><br></pre></td></tr></table></figure><p>grid-template-areas: ‘a . c’<br>                     ‘d . f’<br>                     ‘g . i’;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</span><br></pre></td></tr></table></figure><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p><p>比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5.grid-auto-flow 属性</span><br><span class="line">***</span><br><span class="line">划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是&quot;先行后列&quot;，即先填满第一行，再开始放入第二行，即下图数字的顺序。</span><br><span class="line"></span><br><span class="line">这个顺序由grid-auto-flow属性决定，默认值是row，即&quot;先行后列&quot;。也可以将它设成column，变成&quot;先列后行&quot;。</span><br></pre></td></tr></table></figure><p>grid-auto-flow: column;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面代码设置了column以后，放置顺序就变成纵向。</span><br><span class="line">&gt;[查看示例](https://jsbin.com/yuzupej/edit?html,css,output)</span><br><span class="line"></span><br><span class="line">grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</span><br><span class="line">设为row dense，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。</span><br></pre></td></tr></table></figure><p>grid-auto-flow: row dense;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;[示例](https://jsbin.com/dakafuw/edit?html,css,output)</span><br><span class="line"></span><br><span class="line">如果将设置改为column dense，表示&quot;先列后行&quot;，并且尽量填满空格。</span><br></pre></td></tr></table></figure><p>grid-auto-flow: column dense;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;[示例](https://jsbin.com/fequyuq/edit?html,css,output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.justify-items 属性，</span><br><span class="line">align-items 属性，</span><br><span class="line">place-items 属性</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。</span><br></pre></td></tr></table></figure><p>.container {<br>  justify-items: start | end | center | stretch;<br>  align-items: start | end | center | stretch;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这两个属性的写法完全相同，都可以取下面这些值。</span><br></pre></td></tr></table></figure><p>start：对齐单元格的起始边缘。<br>end：对齐单元格的结束边缘。<br>center：单元格内部居中。<br>stretch：拉伸，占满单元格的整个宽度（默认值）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">.container &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/pipoyuv/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>place-items属性是align-items属性和justify-items属性的合并简写形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><p>7.justify-content 属性，<br>align-content 属性，<br>place-content 属性</p><hr><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start - 对齐容器的起始边框。</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/pipoyuv/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>8.grid-auto-columns 属性，<br>grid-auto-rows 属性</p><hr><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。<br>下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-auto-rows: 50px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/cuwagam/edit?html,css,output" target="_blank" rel="noopener">查看示例</a></p></blockquote><p>9.grid-template 属性，<br>grid 属性;</p><hr><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p><p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h3 id="三、项目属性"><a href="#三、项目属性" class="headerlink" title="三、项目属性"></a>三、项目属性</h3><hr><p>下面这些属性定义在项目上面。</p><p>1.<br>grid-column-start 属性，<br>grid-column-end 属性，<br>grid-row-start 属性，<br>grid-row-end 属性</p><hr><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid-column-start属性：左边框所在的垂直网格线</span><br><span class="line">grid-column-end属性：右边框所在的垂直网格线</span><br><span class="line">grid-row-start属性：上边框所在的水平网格线</span><br><span class="line">grid-row-end属性：下边框所在的水平网格线</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 2;</span><br><span class="line">  grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/dokujup/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>上例中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。</p><p>下面的例子是指定四个边框位置的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-row-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/wuvocis/1/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: header-start;</span><br><span class="line">  grid-column-end: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: span 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，1号项目的左边框距离右边框跨越2个网格。<br>这与下面的代码效果完全一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-end: span 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/micohoy/1/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</p><p>2.grid-column 属性，<br>grid-row 属性</p><hr><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  grid-column:  / ;</span><br><span class="line">  grid-row:  / ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column: 1 / 3;</span><br><span class="line">  grid-row: 1 / 2;</span><br><span class="line">&#125;</span><br><span class="line">/* 等同于 */</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 1;</span><br><span class="line">  grid-row-end: 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用span关键字，表示跨越多少个网格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  background: #b03532;</span><br><span class="line">  grid-column: 1 / 3;</span><br><span class="line">  grid-row: 1 / 3;</span><br><span class="line">&#125;</span><br><span class="line">/* 等同于 */</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  background: #b03532;</span><br><span class="line">  grid-column: 1 / span 2;</span><br><span class="line">  grid-row: 1 / span 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><blockquote><p><a href="https://jsbin.com/mahehis/1/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column: 1;</span><br><span class="line">  grid-row: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目item-1占据左上角第一个网格</p><p>3.grid-area 属性</p><hr><p>grid-area属性指定项目放在哪一个区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，1号项目位于e区域，效果查看示例。</p><blockquote><p><a href="https://jsbin.com/rufafup/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: 1 / 1 / 3 / 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jsbin.com/bigotaz/1/edit?html,css,output" target="_blank" rel="noopener">示例</a></p></blockquote><p>4.justify-self 属性，<br>align-self 属性，<br>place-self 属性</p><hr><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p><p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  align-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start：对齐单元格的起始边缘。</span><br><span class="line">end：对齐单元格的结束边缘。</span><br><span class="line">center：单元格内部居中。</span><br><span class="line">stretch：拉伸，占满单元格的整个宽度（默认值）。</span><br></pre></td></tr></table></figure><p>下面是justify-self: start的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1  &#123;</span><br><span class="line">  justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>place-self属性是align-self属性和justify-self属性的合并简写形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，place-self属性会认为这两个值相等。</p><hr><ul><li>flex弹性布局</li><li>cloumn多列布局</li></ul><hr><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li>transform变形</li><li>transition 动画过渡</li><li>animation 帧动画</li></ul><hr><h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><ul><li>background 背景</li><li>border-radius 圆角</li><li>shadow 阴影</li><li>gradient 渐变</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;css简单整理&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;CSS3&quot;&gt;&lt;a href=&quot;#CSS3&quot; class=&quot;headerlink&quot; title=&quot;CSS3&quot;&gt;&lt;/a&gt;CSS3&lt;/h1&gt;&lt;h2 id=&quot;页面布局&quot;&gt;&lt;a href=&quot;#页面布局&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动和BFC</title>
    <link href="http://yoursite.com/2019/06/26/test/"/>
    <id>http://yoursite.com/2019/06/26/test/</id>
    <published>2019-06-26T10:20:27.000Z</published>
    <updated>2020-03-24T10:38:37.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>清除浮动的方法：</p><ol><li>clear:both<br>clear：both：本质就是闭合浮动， 就是让父盒子闭合出口和入口，不让子盒子出来</li></ol><ul><li>在最后一个浮动的标签后面添加一个标签，给该标签设置clear:both （不推荐，添加了无意义标签，语义化不好）</li><li>给父标签设置伪元素:after或者:before ,给伪元素设置clear:both</li></ul><p>Clear属性存在的值有left,right,both,none,inherit.<br>left/right 针对一边清除浮动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;/*伪元素是行内元素 正常浏览器清除浮动方法*/</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">height: 0;</span><br><span class="line">clear:both;</span><br><span class="line">visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">*zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>overflow hidden或者auto<br>给父元素设置overflow：hidden/auto (不推荐,内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.fahter&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">border: 1px solid deeppink;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。<br>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p><ul><li><p>Box :css布局的基本单位<br>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子</p></li><li><p>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p></li><li><p>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</p></li><li><p>run-in box: css3 中才有， 将元素指定为run-in类型或者compact类型时，如果元素后面还有block类型的元素，run-in类型的元素将被包含在后面的block类型的元素内部，而compact类型的元素将被放置在block类型的元素左边</p></li><li><p>Formatting context :W3C CSS2.1 规范中的一个概念<br>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC).</p><h3 id="BFC布局的规则"><a href="#BFC布局的规则" class="headerlink" title="BFC布局的规则"></a>BFC布局的规则</h3></li><li><p>内部的Box会在垂直方向，一个接一个地放置</p></li><li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p></li><li><p>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</p></li><li><p>BFC的区域不会与float box重叠。</p></li><li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></li><li><p>计算BFC的高度时，浮动元素也参与计算</p><h3 id="创建BFC"><a href="#创建BFC" class="headerlink" title="创建BFC"></a>创建BFC</h3></li><li><p>float的值不是none</p></li><li><p>position的值不是static或者relative</p></li><li><p>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</p></li><li><p>overflow的值为hidden或auto</p><h3 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h3></li></ul><ol><li>利用BFC避免margin重叠<blockquote><p><a href="https://jsbin.com/fozuwec/edit?html,css,output" target="_blank" rel="noopener">点击这个查看示例</a></p></blockquote></li><li>自适应两栏布局<blockquote><p><a href="https://jsbin.com/yuzupej/edit?html,css,output" target="_blank" rel="noopener">点击这个查看示例</a></p></blockquote></li><li>清除浮动<br>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;清除浮动&quot;&gt;&lt;a href=&quot;#清除浮动&quot; class=&quot;headerlink&quot; title=&quot;清除浮动&quot;&gt;&lt;/a&gt;清除浮动&lt;/h2&gt;&lt;p&gt;清除浮动的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;clear:both&lt;br&gt;clear：both：本质就是闭合浮动， 就是让父盒
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
</feed>
